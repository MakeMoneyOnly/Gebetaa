# SKILL: tdd-testing

## Purpose

Implement Test-Driven Development workflows that ensure code quality, prevent regressions, and document system behavior. This skill covers unit tests, integration tests, and end-to-end testing strategies.

## When to Use

- Before writing any new feature code
- When fixing bugs (write test first)
- When refactoring existing code
- When establishing testing patterns for a team
- During code review to verify coverage

## Role Activated

**Senior QA Engineer + TDD Practitioner**

You think like a quality-obsessed engineer at Google or Microsoft—tests are not an afterthought but the foundation of reliable software.

## Inputs (Variables)

```yaml
{feature_requirements}: What needs to be built
{existing_codebase}: Current code structure
{test_framework}: Jest, Vitest, Pytest, Go testing
{coverage_target}: Minimum coverage percentage
{ci_integration}: How tests run in CI

Step-by-Step Process
Step 1: TDD Cycle (Red-Green-Refactor)
markdownDownloadCopy code## The TDD Cycle

### 1. RED: Write a Failing Test
Write a test that describes the behavior you want. It must fail initially.

### 2. GREEN: Make It Pass
Write the minimum code necessary to make the test pass. No more.

### 3. REFACTOR: Clean Up
Improve the code while keeping tests green. Remove duplication.

### Repeat
Continue the cycle for each piece of functionality.
typescriptDownloadCopy code// Example: Building a User Service with TDD

// Step 1: RED - Write failing test
describe('UserService', () => {
  describe('createUser', () => {
    it('should create a user with valid data', async () => {
      const userService = new UserService(mockRepo);
      
      const result = await userService.createUser({
        email: 'test@example.com',
        name: 'Test User',
        password: 'securePassword123',
      });

      expect(result).toMatchObject({
        email: 'test@example.com',
        name: 'Test User',
      });
      expect(result.id).toBeDefined();
      expect(result.passwordHash).toBeUndefined(); // Never expose
    });
  });
});

// Step 2: GREEN - Minimal implementation
class UserService {
  constructor(private repo: UsersRepository) {}

  async createUser(data: CreateUserDto) {
    const user = await this.repo.create({
      ...data,
      passwordHash: await hash(data.password),
    });
    const { passwordHash, ...safeUser } = user;
    return safeUser;
  }
}

// Step 3: REFACTOR - Add validation, error handling
Step 2: Unit Testing Patterns
typescriptDownloadCopy code// tests/unit/services/users.service.test.ts
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { UserService } from '@/services/users.service';
import { UsersRepository } from '@/repositories/users.repository';

// Mock the repository
vi.mock('@/repositories/users.repository');

describe('UserService', () => {
  let userService: UserService;
  let mockRepo: vi.Mocked<UsersRepository>;

  beforeEach(() => {
    mockRepo = {
      findById: vi.fn(),
      findByEmail: vi.fn(),
      findAll: vi.fn(),
      create: vi.fn(),
      update: vi.fn(),
      delete: vi.fn(),
    } as any;
    
    userService = new UserService(mockRepo);
  });

  describe('findById', () => {
    it('should return user when found', async () => {
      const mockUser = { id: '1', email: 'test@example.com', name: 'Test' };
      mockRepo.findById.mockResolvedValue(mockUser);

      const result = await userService.findById('1');

      expect(result).toEqual(mockUser);
      expect(mockRepo.findById).toHaveBeenCalledWith('1');
    });

    it('should throw NotFoundError when user not found', async () => {
      mockRepo.findById.mockResolvedValue(null);

      await expect(userService.findById('999'))
        .rejects
        .toThrow('User not found');
    });
  });

  describe('createUser', () => {
    it('should hash password before saving', async () => {
      const input = {
        email: 'new@example.com',
        password: 'password123',
        name: 'New User',
      };
      
      mockRepo.findByEmail.mockResolvedValue(null);
      mockRepo.create.mockImplementation(async (data) => ({
        id: '1',
        ...data,
        createdAt: new Date(),
      }));

      await userService.createUser(input);

      expect(mockRepo.create).toHaveBeenCalledWith(
        expect.objectContaining({
          email: input.email,
          name: input.name,
          passwordHash: expect.any(String),
        })
      );
      // Verify password was not stored in plain text
      expect(mockRepo.create).not.toHaveBeenCalledWith(
        expect.objectContaining({ password: input.password })
      );
    });

    it('should throw error if email already exists', async () => {
      mockRepo.findByEmail.mockResolvedValue({ id: '1', email: 'existing@example.com' });

      await expect(
        userService.createUser({
          email: 'existing@example.com',
          password: 'password',
          name: 'Test',
        })
      ).rejects.toThrow('Email already registered');
    });
  });
});
Step 3: Integration Testing
typescriptDownloadCopy code// tests/integration/api/users.test.ts
import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import request from 'supertest';
import app from '@/app';
import { prisma } from '@/lib/database';
import { createTestUser, generateAuthToken } from '../helpers';

describe('Users API', () => {
  let authToken: string;
  let testUser: any;

  beforeAll(async () => {
    // Setup test database
    await prisma.\$connect();
  });

  afterAll(async () => {
    await prisma.\$disconnect();
  });

  beforeEach(async () => {
    // Clean database before each test
    await prisma.user.deleteMany();
    
    // Create test user and token
    testUser = await createTestUser();
    authToken = generateAuthToken(testUser);
  });

  describe('GET /api/v1/users', () => {
    it('should return paginated users', async () => {
      // Create additional users
      await createTestUser({ email: 'user2@example.com' });
      await createTestUser({ email: 'user3@example.com' });

      const response = await request(app)
        .get('/api/v1/users')
        .set('Authorization', `Bearer ${authToken}`)
        .query({ page: 1, limit: 10 });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveLength(3);
      expect(response.body.meta.pagination).toMatchObject({
        total: 3,
        page: 1,
        limit: 10,
      });
    });

    it('should filter users by search query', async () => {
      await createTestUser({ email: 'john@example.com', name: 'John Doe' });
      await createTestUser({ email: 'jane@example.com', name: 'Jane Smith' });

      const response = await request(app)
        .get('/api/v1/users')
        .set('Authorization', `Bearer ${authToken}`)
        .query({ search: 'john' });

      expect(response.status).toBe(200);
      expect(response.body.data).toHaveLength(1);
      expect(response.body.data[0].name).toBe('John Doe');
    });

    it('should return 401 without auth token', async () => {
      const response = await request(app).get('/api/v1/users');

      expect(response.status).toBe(401);
      expect(response.body.error.code).toBe('UNAUTHORIZED');
    });
  });

  describe('POST /api/v1/users', () => {
    it('should create new user with valid data', async () => {
      const newUser = {
        email: 'newuser@example.com',
        password: 'securePassword123',
        name: 'New User',
      };

      const response = await request(app)
        .post('/api/v1/users')
        .set('Authorization', `Bearer ${authToken}`)
        .send(newUser);

      expect(response.status).toBe(201);
      expect(response.body.data).toMatchObject({
        email: newUser.email,
        name: newUser.name,
      });
      expect(response.body.data.passwordHash).toBeUndefined();
    });

    it('should return 400 for invalid email', async () => {
      const response = await request(app)
        .post('/api/v1/users')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          email: 'invalid-email',
          password: 'password123',
          name: 'Test',
        });

      expect(response.status).toBe(400);
      expect(response.body.error.code).toBe('VALIDATION_ERROR');
    });
  });
});
Step 4: End-to-End Testing
typescriptDownloadCopy code// tests/e2e/auth-flow.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Authentication Flow', () => {
  test.beforeEach(async ({ page }) => {
    // Reset database state via API
    await fetch(`${process.env.API_URL}/test/reset`, { method: 'POST' });
  });

  test('complete registration and login flow', async ({ page }) => {
    // Visit registration page
    await page.goto('/register');
    
    // Fill registration form
    await page.getByLabel('Name').fill('Test User');
    await page.getByLabel('Email').fill('test@example.com');
    await page.getByLabel('Password').fill('SecurePass123!');
    await page.getByLabel('Confirm Password').fill('SecurePass123!');
    
    // Submit form
    await page.getByRole('button', { name: 'Create Account' }).click();
    
    // Should redirect to dashboard
    await expect(page).toHaveURL('/dashboard');
    await expect(page.getByText('Welcome, Test User')).toBeVisible();

    // Logout
    await page.getByRole('button', { name: 'Profile' }).click();
    await page.getByRole('menuitem', { name: 'Logout' }).click();
    
    // Should redirect to login
    await expect(page).toHaveURL('/login');

    // Login with created credentials
    await page.getByLabel('Email').fill('test@example.com');
    await page.getByLabel('Password').fill('SecurePass123!');
    await page.getByRole('button', { name: 'Sign In' }).click();

    // Should be back on dashboard
    await expect(page).toHaveURL('/dashboard');
  });

  test('shows validation errors for invalid input', async ({ page }) => {
    await page.goto('/register');
    
    // Submit empty form
    await page.getByRole('button', { name: 'Create Account' }).click();
    
    // Should show validation errors
    await expect(page.getByText('Name is required')).toBeVisible();
    await expect(page.getByText('Email is required')).toBeVisible();
    await expect(page.getByText('Password is required')).toBeVisible();
  });

  test('prevents registration with existing email', async ({ page }) => {
    // Create user via API
    await fetch(`${process.env.API_URL}/test/create-user`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email: 'existing@example.com' }),
    });

    await page.goto('/register');
    
    await page.getByLabel('Name').fill('Test');
    await page.getByLabel('Email').fill('existing@example.com');
    await page.getByLabel('Password').fill('Password123!');
    await page.getByLabel('Confirm Password').fill('Password123!');
    await page.getByRole('button', { name: 'Create Account' }).click();
    
    await expect(page.getByText('Email already registered')).toBeVisible();
  });
});
Step 5: Component Testing
typescriptDownloadCopy code// tests/components/Button.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import { Button } from '@/components/ui/button';

describe('Button', () => {
  it('renders with correct text', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByRole('button', { name: 'Click me' })).toBeInTheDocument();
  });

  it('calls onClick handler when clicked', () => {
    const handleClick = vi.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    
    fireEvent.click(screen.getByRole('button'));
    
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('shows loading state', () => {
    render(<Button loading>Submit</Button>);
    
    expect(screen.getByRole('button')).toHaveAttribute('aria-busy', 'true');
    expect(screen.getByRole('button')).toBeDisabled();
  });

  it('applies variant styles', () => {
    const { rerender } = render(<Button variant="primary">Primary</Button>);
    expect(screen.getByRole('button')).toHaveClass('bg-primary-600');

    rerender(<Button variant="secondary">Secondary</Button>);
    expect(screen.getByRole('button')).toHaveClass('bg-neutral-100');
  });

  it('is accessible', () => {
    render(<Button aria-label="Close dialog">×</Button>);
    expect(screen.getByLabelText('Close dialog')).toBeInTheDocument();
  });
});
Step 6: Test Configuration
typescriptDownloadCopy code// vitest.config.ts
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: ['./tests/setup.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'tests/',
        '**/*.d.ts',
        '**/*.config.*',
      ],
      thresholds: {
        lines: 80,
        functions: 80,
        branches: 80,
        statements: 80,
      },
    },
    include: ['tests/**/*.test.{ts,tsx}'],
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});

// tests/setup.ts
import '@testing-library/jest-dom';
import { vi } from 'vitest';

// Mock environment variables
vi.stubEnv('API_URL', 'http://localhost:3001');
vi.stubEnv('JWT_SECRET', 'test-secret');

// Global test utilities
global.createMockUser = () => ({
  id: 'user-1',
  email: 'test@example.com',
  name: 'Test User',
});
Step 7: CI Integration
yamlDownloadCopy code# .github/workflows/test.yml
name: Test

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      - run: npm ci
      - run: npm run test:unit -- --coverage
      - uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info

  integration-tests:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: test
        ports:
          - 5432:5432
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm ci
      - run: npx prisma migrate deploy
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/test
      - run: npm run test:integration
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/test

  e2e-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm ci
      - run: npx playwright install --with-deps
      - run: npm run build
      - run: npm run test:e2e
      - uses: actions/upload-artifact@v3
        if: failure()
        with:
          name: playwright-report
          path: playwright-report/
Outputs

1. TDD Workflow - Red-Green-Refactor cycle documentation
2. Unit Tests - Service and utility test patterns
3. Integration Tests - API endpoint test patterns
4. E2E Tests - User flow test patterns
5. Component Tests - UI component test patterns
6. Test Configuration - Vitest/Jest setup
7. CI Pipeline - Automated test execution

Quality Gates
GateCriteriaStatusCoverage> 80% line coverageUnit TestsAll services have testsIntegrationAll API endpoints testedE2ECritical flows coveredCIAll tests pass in CI
References & Best Practices
From Martin Fowler

* "Tests are documentation that never goes out of date."
* Test behavior, not implementation.

From Kent Beck

* "Test-Driven Development is a way of managing fear during programming."
* Write the test you wish you had.