# SKILL: debugging-mastery

## Purpose

Apply systematic debugging methodologies to identify root causes, form hypotheses, create targeted fixes, and document the process for future reference. Debug like a senior engineer, not through random changes.

## When to Use

- When encountering unexpected behavior
- When tests fail unexpectedly
- When production issues arise
- When performance degrades
- When investigating user-reported bugs

## Role Activated

**Senior Debugging Specialist + Systems Detective**

You think like Julia Evans debugging Linux internals—methodical, curious, and relentlessly systematic.

## Inputs (Variables)

```yaml
{symptom}: Observable problem description
{expected_behavior}: What should happen
{actual_behavior}: What actually happens
{context}: Environment, recent changes, conditions
{severity}: Impact level and urgency

Step-by-Step Process
Step 1: Problem Definition
markdownDownloadCopy code## Bug Report Template

### Summary
[One-line description of the issue]

### Environment
- **Application Version:** 
- **Browser/Client:** 
- **Operating System:** 
- **Environment:** Production / Staging / Development

### Steps to Reproduce
1. [Step 1]
2. [Step 2]
3. [Step 3]

### Expected Behavior
[What should happen]

### Actual Behavior
[What actually happens]

### Error Messages
[Paste any error messages, stack traces, or logs]

### Screenshots/Recordings
[Attach if applicable]

### Frequency
- [ ] Always reproducible
- [ ] Intermittent (X% of the time)
- [ ] Only under specific conditions

### Recent Changes
[Any deployments, config changes, or updates before this started?]

### Impact
- [ ] Critical - System unusable
- [ ] High - Major feature broken
- [ ] Medium - Feature degraded
- [ ] Low - Minor inconvenience

Step 2: Hypothesis Formation
markdownDownloadCopy code## Hypothesis Framework

### The Scientific Method for Debugging

1. **Observe** - Gather all available information
2. **Hypothesize** - Form testable theories
3. **Predict** - What would confirm/deny each hypothesis?
4. **Test** - Design experiments to test hypotheses
5. **Conclude** - Accept or reject hypotheses
6. **Repeat** - Refine and continue

### Hypothesis Table

| # | Hypothesis | Test | Expected Result | Actual Result | Status |
|---|------------|------|-----------------|---------------|--------|
| 1 | Database query timeout | Check query execution time | < 30s | | Pending |
| 2 | Memory leak in service | Monitor memory over time | Stable | | Pending |
| 3 | Race condition in async code | Add logging, check order | Sequential | | Pending |

### Prioritization
Order hypotheses by:
1. Probability (most likely first)
2. Ease of testing (quick tests first)
3. Impact (high-impact causes first)
Step 3: Information Gathering
typescriptDownloadCopy code// Strategic logging for debugging
const debugLogger = {
  // Add context to all logs
  context: (operation: string, data: Record<string, unknown>) => {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      operation,
      ...data,
      requestId: getRequestId(),
      userId: getCurrentUserId(),
    }));
  },

  // Time operations
  time: async <T>(label: string, fn: () => Promise<T>): Promise<T> => {
    const start = performance.now();
    try {
      const result = await fn();
      console.log(`[TIMING] ${label}: ${(performance.now() - start).toFixed(2)}ms`);
      return result;
    } catch (error) {
      console.log(`[TIMING] ${label}: FAILED after ${(performance.now() - start).toFixed(2)}ms`);
      throw error;
    }
  },

  // Trace function calls
  trace: (fn: Function) => {
    return function(...args: unknown[]) {
      console.log(`[TRACE] Entering ${fn.name} with:`, args);
      const result = fn.apply(this, args);
      console.log(`[TRACE] Exiting ${fn.name} with:`, result);
      return result;
    };
  },
};

// Usage
await debugLogger.time('fetchUserData', async () => {
  debugLogger.context('db_query', { table: 'users', id: userId });
  return await db.users.findUnique({ where: { id: userId } });
});
Step 4: Isolation Techniques
markdownDownloadCopy code## Isolation Strategies

### Binary Search Debugging
When: Bug exists but unclear where

1. Identify the full code path
2. Add checkpoint at midpoint
3. Determine which half contains bug
4. Repeat until isolated

Start → [A] → [B] → [C] → [D] → [E] → End
↑
Add checkpoint here first
If bug before C: Search A-B
If bug after C: Search D-E

### Git Bisect for Regression
```bash
# Start bisect
git bisect start

# Mark current (broken) commit as bad
git bisect bad

# Mark known good commit
git bisect good v1.2.0

# Git checks out middle commit - test and mark
git bisect good  # or git bisect bad

# Repeat until found
# Git will identify the first bad commit

# End bisect
git bisect reset

Environment Isolation
bashDownloadCopy code# Test in isolation
docker run --rm -it \
  -e DATABASE_URL=postgresql://test:test@host/test \
  -e DEBUG=true \
  myapp:latest \
  node --inspect src/index.js
Minimal Reproduction
typescriptDownloadCopy code// Create smallest possible reproduction
// Remove everything not needed to reproduce the bug

// Instead of testing full flow:
// app.post('/api/projects', authenticate, validate, createProject)

// Test just the failing part:
const result = await projectService.create({
  name: 'Test',
  userId: 'user-1',
});
console.log(result); // Isolate the actual failure

### Step 5: Common Bug Patterns

```markdown
## Bug Pattern Recognition

### Pattern 1: Off-by-One Errors
**Symptoms:** Works for some inputs, fails at boundaries
**Common locations:** Loops, array indexing, pagination
**Fix approach:** Check boundary conditions, use < vs <=

```typescript
// Bug
for (let i = 0; i <= arr.length; i++) { } // Off by one

// Fix
for (let i = 0; i < arr.length; i++) { }

Pattern 2: Race Conditions
Symptoms: Intermittent failures, works sometimes
Common locations: Async code, shared state, database transactions
Fix approach: Add proper synchronization, use transactions
typescriptDownloadCopy code// Bug: Race condition
async function updateCounter() {
  const current = await db.counter.get();
  await db.counter.set(current + 1); // Another request could read between these
}

// Fix: Atomic operation
async function updateCounter() {
  await db.counter.increment();
}
Pattern 3: Null/Undefined Errors
Symptoms: "Cannot read property of undefined"
Common locations: Optional data, API responses, deep object access
Fix approach: Defensive coding, optional chaining
typescriptDownloadCopy code// Bug
const name = user.profile.name; // Crashes if profile is null

// Fix
const name = user?.profile?.name ?? 'Unknown';
Pattern 4: Memory Leaks
Symptoms: Increasing memory, eventual crash
Common locations: Event listeners, closures, caches
Fix approach: Proper cleanup, weak references
typescriptDownloadCopy code// Bug: Event listener never removed
useEffect(() => {
  window.addEventListener('resize', handleResize);
}, []);

// Fix: Cleanup on unmount
useEffect(() => {
  window.addEventListener('resize', handleResize);
  return () => window.removeEventListener('resize', handleResize);
}, []);
Pattern 5: Type Coercion Issues
Symptoms: Unexpected values, "NaN", "[object Object]"
Common locations: String/number mixing, comparisons
Fix approach: Explicit type conversion, strict equality
typescriptDownloadCopy code// Bug
if (userId == 0) { } // '0' == 0 is true in JS

// Fix
if (userId === 0) { }
// Or better: if (typeof userId === 'number' && userId === 0)

### Step 6: Debugging Tools

```markdown
## Debugging Toolkit

### Browser DevTools
```javascript
// Console methods
console.log(obj);           // Basic logging
console.table(array);       // Tabular display
console.dir(obj);           // Object inspection
console.trace();            // Stack trace
console.time('operation');  // Start timer
console.timeEnd('operation'); // End timer
console.group('Group');     // Group logs
console.groupEnd();

// Breakpoints
debugger; // Programmatic breakpoint

// Performance
performance.mark('start');
// ... code ...
performance.mark('end');
performance.measure('operation', 'start', 'end');

Node.js Debugging
bashDownloadCopy code# Inspector
node --inspect src/index.js
node --inspect-brk src/index.js  # Break at start

# Memory debugging
node --expose-gc --inspect src/index.js
Database Debugging
sqlDownloadCopy code-- Explain query plan
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@example.com';

-- Check locks
SELECT * FROM pg_locks WHERE NOT granted;

-- Active queries
SELECT pid, query, state, query_start 
FROM pg_stat_activity 
WHERE state != 'idle';
Network Debugging
bashDownloadCopy code# HTTP requests
curl -v https://api.example.com/endpoint

# DNS
dig api.example.com

# Connection testing
nc -zv api.example.com 443

# SSL/TLS
openssl s_client -connect api.example.com:443

### Step 7: Root Cause Documentation

```markdown
## Root Cause Analysis Template

### Issue: [Title]
**Date:** [Date]
**Severity:** [Critical/High/Medium/Low]
**Duration:** [Time to resolution]

### Summary
[Brief description of what happened]

### Timeline
| Time | Event |
|------|-------|
| HH:MM | First report of issue |
| HH:MM | Investigation started |
| HH:MM | Root cause identified |
| HH:MM | Fix deployed |
| HH:MM | Issue resolved |

### Root Cause
[Detailed explanation of why this happened]

### Contributing Factors
1. [Factor 1]
2. [Factor 2]

### Resolution
[What was done to fix the issue]

### Prevention
[What changes will prevent this in the future]
- [ ] Add test for this case
- [ ] Add monitoring/alerting
- [ ] Update documentation
- [ ] Code/architecture changes

### Lessons Learned
1. [Lesson 1]
2. [Lesson 2]

Outputs

1. Bug Report - Structured problem documentation
2. Hypothesis Table - Systematic theory testing
3. Debug Logs - Strategic logging implementation
4. Isolation Results - Narrowed problem scope
5. Root Cause Analysis - Complete RCA document
6. Prevention Plan - Future safeguards

Quality Gates
GateCriteriaStatusReproducibleBug can be reliably reproducedRoot CauseActual cause identified (not just symptom)Verified FixFix confirmed to resolve issueNo RegressionExisting tests still passDocumentedRCA completed and shared
References & Best Practices
From Julia Evans

* "The key to debugging is to be really systematic."
* Ask: "What do I know? What don't I know? How can I find out?"

From The Pragmatic Engineer

* "Debug with data, not intuition."
* "Every bug is a missing test."