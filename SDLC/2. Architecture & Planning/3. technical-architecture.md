# SKILL: technical-architecture

## Purpose

Design robust, scalable, and maintainable technical architecture that transforms product requirements into implementable system designs. This skill produces Architecture Decision Records (ADRs), system diagrams, and technical specifications that enable confident development.

## When to Use

- After `/product-strategy` produces approved PRD
- Before any significant development begins
- When evaluating build vs. buy decisions
- When scaling existing systems requires redesign
- During technical debt remediation planning
- When integrating new third-party systems

## Role Activated

**Principal Software Architect + Distinguished Engineer**

You think like a senior architect at Stripe, Netflix, or Google—designing for scale, maintainability, and operational excellence while avoiding over-engineering. You balance theoretical best practices with pragmatic delivery.

## Inputs (Variables)

````yaml
{prd}: Product Requirements Document
{scale_requirements}: Expected load, users, data volume
{tech_constraints}: Existing systems, team expertise, budget
{timeline}: Development timeline constraints
{compliance_requirements}: Security, regulatory, compliance needs
{integration_requirements}: External systems to connect with
{team_composition}: Available engineering skills

Step-by-Step Process
Step 1: Requirements Analysis for Architecture
Translate product requirements into technical drivers:
markdownDownloadCopy code## Technical Requirements Analysis

### Functional Requirements Summary
| Requirement | Technical Implication |
|-------------|----------------------|
| [From PRD] | [What this means technically] |

### Non-Functional Requirements (Quality Attributes)

#### Performance
| Metric | Requirement | Justification |
|--------|-------------|---------------|
| Response Time | p50: Xms, p95: Yms, p99: Zms | |
| Throughput | X requests/second | |
| Concurrency | X simultaneous users | |

#### Scalability
| Dimension | Current | Year 1 | Year 3 |
|-----------|---------|--------|--------|
| Users | | | |
| Data Volume | | | |
| Transactions/day | | | |

#### Availability
- Target Uptime: X% (X minutes/year downtime)
- RTO (Recovery Time Objective): X hours
- RPO (Recovery Point Objective): X hours

#### Security
- Authentication: [Requirements]
- Authorization: [Requirements]
- Data Protection: [At rest/in transit requirements]
- Compliance: [GDPR/SOC2/HIPAA/PCI-DSS]

#### Maintainability
- Deployment Frequency Target: [X per day/week]
- Mean Time to Recovery Target: [X minutes]
- Code Quality Standards: [Coverage %, etc.]

### Technical Constraints
| Constraint | Impact | Mitigation |
|------------|--------|------------|
| | | |

### Integration Requirements
| System | Protocol | Data Flow | Criticality |
|--------|----------|-----------|-------------|
| | REST/GraphQL/gRPC/Webhook | In/Out/Bidirectional | Critical/Important/Nice-to-have |
Step 2: Architecture Decision Records (ADRs)
Document key technical decisions:
markdownDownloadCopy code## Architecture Decision Record Template

### ADR-001: [Decision Title]

**Status:** Proposed | Accepted | Deprecated | Superseded

**Date:** [YYYY-MM-DD]

**Decision Makers:** [Names/Roles]

#### Context
[What is the issue that we're seeing that is motivating this decision or change?]

#### Decision Drivers
- [Driver 1]
- [Driver 2]
- [Driver 3]

#### Considered Options
1. **[Option 1]**: [Brief description]
2. **[Option 2]**: [Brief description]
3. **[Option 3]**: [Brief description]

#### Decision Outcome
**Chosen Option:** [Option X]

**Reasoning:** [Why this option was selected]

#### Pros and Cons of Options

**Option 1: [Name]**
| Pros | Cons |
|------|------|
| + [Pro] | - [Con] |

**Option 2: [Name]**
| Pros | Cons |
|------|------|
| + [Pro] | - [Con] |

**Option 3: [Name]**
| Pros | Cons |
|------|------|
| + [Pro] | - [Con] |

#### Consequences
**Positive:**
- [Consequence]

**Negative:**
- [Consequence]

**Risks:**
- [Risk and mitigation]

#### Validation
[How will we know if this decision was correct?]

---

## Key ADRs for This Project

### ADR-001: Primary Programming Language/Framework
[Full ADR]

### ADR-002: Database Technology Selection
[Full ADR]

### ADR-003: API Design Approach
[Full ADR]

### ADR-004: Deployment Strategy
[Full ADR]

### ADR-005: Authentication/Authorization Approach
[Full ADR]
Step 3: System Architecture Diagrams
Create multi-level architecture views:
markdownDownloadCopy code## Architecture Diagrams

### C4 Level 1: System Context

```mermaid
C4Context
    title System Context Diagram - [System Name]

    Person(user, "End User", "Primary user of the system")
    Person(admin, "Administrator", "Manages system configuration")

    System(system, "Our System", "Core system being designed")

    System_Ext(auth, "Auth Provider", "Identity management")
    System_Ext(payment, "Payment Provider", "Payment processing")
    System_Ext(email, "Email Service", "Transactional email")
    System_Ext(analytics, "Analytics", "Usage tracking")

    Rel(user, system, "Uses", "HTTPS")
    Rel(admin, system, "Configures", "HTTPS")
    Rel(system, auth, "Authenticates via", "OIDC")
    Rel(system, payment, "Processes payments", "API")
    Rel(system, email, "Sends email via", "API")
    Rel(system, analytics, "Sends events to", "API")
C4 Level 2: Container Diagram
mermaidDownloadCopy codeC4Container
    title Container Diagram - [System Name]

    Person(user, "User")

    Container_Boundary(system, "Our System") {
        Container(web, "Web Application", "React/Next.js", "Serves the SPA")
        Container(api, "API Server", "Node.js/Python/Go", "Handles business logic")
        Container(worker, "Background Worker", "Same as API", "Async job processing")
        ContainerDb(db, "Primary Database", "PostgreSQL", "Stores core data")
        ContainerDb(cache, "Cache", "Redis", "Session & data cache")
        ContainerDb(queue, "Message Queue", "Redis/SQS", "Job queue")
        ContainerDb(storage, "Object Storage", "S3", "File storage")
    }

    Rel(user, web, "Uses", "HTTPS")
    Rel(web, api, "Calls", "HTTPS/JSON")
    Rel(api, db, "Reads/Writes")
    Rel(api, cache, "Caches")
    Rel(api, queue, "Enqueues jobs")
    Rel(worker, queue, "Processes jobs")
    Rel(worker, db, "Reads/Writes")
    Rel(api, storage, "Stores files")
C4 Level 3: Component Diagram (for critical containers)
mermaidDownloadCopy codeC4Component
    title Component Diagram - API Server

    Container_Boundary(api, "API Server") {
        Component(router, "Router", "Express/FastAPI", "HTTP routing")
        Component(auth, "Auth Module", "Middleware", "Authentication & authorization")
        Component(users, "Users Service", "Module", "User management")
        Component(core, "Core Service", "Module", "Main business logic")
        Component(integrations, "Integrations", "Module", "Third-party integrations")
        Component(data, "Data Access", "Repository", "Database operations")
    }

    Rel(router, auth, "Validates requests")
    Rel(auth, users, "Gets user context")
    Rel(router, core, "Routes to")
    Rel(core, data, "Uses")
    Rel(core, integrations, "Calls")
Data Flow Diagram
mermaidDownloadCopy codeflowchart LR
    subgraph Client
        A[Browser/Mobile]
    end

    subgraph Edge
        B[CDN]
        C[Load Balancer]
    end

    subgraph Application
        D[Web Server]
        E[API Server]
        F[Worker]
    end

    subgraph Data
        G[(Primary DB)]
        H[(Read Replica)]
        I[(Cache)]
        J[(Queue)]
    end

    A --> B --> C --> D
    D --> E
    E --> G
    E --> I
    E --> J
    F --> J
    F --> G
    G --> H
    E --> H
Deployment Architecture
mermaidDownloadCopy codeflowchart TB
    subgraph Cloud Provider
        subgraph Region
            subgraph VPC
                subgraph Public Subnet
                    LB[Load Balancer]
                    NAT[NAT Gateway]
                end
                subgraph Private Subnet
                    subgraph ECS/K8s Cluster
                        API1[API Pod 1]
                        API2[API Pod 2]
                        Worker1[Worker Pod]
                    end
                end
                subgraph Data Subnet
                    DB[(RDS Primary)]
                    DBR[(RDS Replica)]
                    Redis[(ElastiCache)]
                end
            end
        end
        S3[S3 Bucket]
        CF[CloudFront]
    end

    Internet --> CF --> LB
    LB --> API1 & API2
    API1 & API2 --> DB & Redis
    Worker1 --> DB

### Step 4: Data Architecture

Design the data layer:

```markdown
## Data Architecture

### Entity-Relationship Diagram

```mermaid
erDiagram
    USER ||--o{ ORGANIZATION_MEMBER : "belongs to"
    ORGANIZATION ||--o{ ORGANIZATION_MEMBER : "has"
    USER ||--o{ PROJECT : "creates"
    ORGANIZATION ||--o{ PROJECT : "owns"
    PROJECT ||--o{ RESOURCE : "contains"
    USER ||--o{ AUDIT_LOG : "generates"

    USER {
        uuid id PK
        string email UK
        string name
        timestamp created_at
        timestamp updated_at
    }

    ORGANIZATION {
        uuid id PK
        string name
        string slug UK
        jsonb settings
        timestamp created_at
    }

    PROJECT {
        uuid id PK
        uuid organization_id FK
        uuid created_by FK
        string name
        string status
        timestamp created_at
    }

Data Storage Strategy
Data TypeStorageRationaleRetentionCore business dataPostgreSQLACID, relationsIndefiniteSessionsRedisSpeed, TTL24 hoursFile uploadsS3Scalability, costPolicy-basedLogsCloudWatch/DatadogAnalysis90 daysAnalytics eventsSegment → WarehouseScaleIndefinite
Data Flow & Sync
SourceDestinationMechanismFrequency
Backup & Recovery Strategy
Data StoreBackup MethodFrequencyRetentionRTORPOPostgreSQLAutomated snapshotsDaily30 days1h24hPostgreSQLPoint-in-timeContinuous7 days15m5mS3Cross-region replicationReal-timeN/A00RedisSnapshotsHourly24h15m1h

### Step 5: API Design

Define API architecture:

```markdown
## API Architecture

### API Style Decision
**Chosen:** [REST | GraphQL | gRPC | Hybrid]
**Rationale:** [Why this choice for this system]

### REST API Design (if applicable)

#### Base URL Structure

Production: https://api.example.com/v1
Staging: https://api.staging.example.com/v1

#### Authentication
- **Method:** Bearer Token (JWT) / API Key / OAuth2
- **Header:** `Authorization: Bearer <token>`
- **Token Lifetime:** [X hours/days]

#### Versioning Strategy
- URL-based: `/v1/`, `/v2/`
- Header-based: `API-Version: 2024-01-01`

#### Standard Response Format
```json
{
  "data": {},
  "meta": {
    "request_id": "uuid",
    "timestamp": "ISO8601"
  }
}

Error Response Format
jsonDownloadCopy code{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Human readable message",
    "details": [
      {
        "field": "email",
        "message": "Invalid email format"
      }
    ]
  },
  "meta": {
    "request_id": "uuid",
    "timestamp": "ISO8601"
  }
}
HTTP Status Code Usage
CodeUsage200Successful GET, PUT, PATCH201Successful POST (created)204Successful DELETE400Validation error401Authentication required403Forbidden (authorized but not permitted)404Resource not found409Conflict (duplicate, etc.)422Unprocessable entity429Rate limited500Server error
Endpoint Design
EndpointMethodPurposeAuthRate Limit/usersGETList usersYes100/min/usersPOSTCreate userYes10/min/users/{id}GETGet userYes100/min/users/{id}PATCHUpdate userYes50/min/users/{id}DELETEDelete userYes10/min
Pagination
GET /resources?page=1&per_page=20
GET /resources?cursor=abc123&limit=20

Filtering & Sorting
GET /resources?status=active&sort=-created_at

GraphQL API Design (if applicable)
[Schema design, query/mutation organization]
API Security Checklist

*  All endpoints require authentication (except public)
*  Rate limiting implemented
*  Input validation on all endpoints
*  SQL injection prevention
*  CORS configured correctly
*  Sensitive data not logged
*  API keys rotatable


### Step 6: Security Architecture

Design security controls:

```markdown
## Security Architecture

### Security Model

```mermaid
flowchart TB
    subgraph External
        User[User]
        Attacker[Threat Actor]
    end

    subgraph Perimeter
        WAF[WAF]
        CDN[CDN/DDoS Protection]
    end

    subgraph Application
        Auth[Auth Service]
        API[API Server]
        Secrets[Secrets Manager]
    end

    subgraph Data
        Encrypted[(Encrypted DB)]
    end

    User --> CDN --> WAF --> Auth --> API --> Encrypted
    API --> Secrets
    Attacker -.->|Blocked| WAF

Authentication Design
AspectDecisionImplementationUser AuthService AuthToken TypeToken StorageSession Management
Authorization Model

* Model: [RBAC / ABAC / ReBAC]
* Implementation: [Custom / Library / Service]

Roles & Permissions
RolePermissionsScopeAdminAllOrganizationMemberRead, WriteAssigned resourcesViewerReadAssigned resources
Data Protection
Data ClassAt RestIn TransitAccess ControlPIIAES-256TLS 1.3Need-to-knowCredentialsHashed (bcrypt)TLS 1.3Auth service onlyBusiness DataAES-256TLS 1.3Role-based
Security Compliance Checklist

*  OWASP Top 10 mitigations
*  Dependency vulnerability scanning
*  Secret rotation capability
*  Audit logging for sensitive operations
*  Penetration testing scheduled


### Step 7: Infrastructure Architecture

Define infrastructure requirements:

```markdown
## Infrastructure Architecture

### Cloud Provider Selection
**Chosen:** [AWS / GCP / Azure / Multi-cloud]
**Rationale:** [Team expertise, cost, features]

### Resource Specifications

#### Compute
| Service | Environment | Size | Count | Cost/Month |
|---------|-------------|------|-------|------------|
| API Servers | Production | [size] | [count] | |
| Workers | Production | [size] | [count] | |
| API Servers | Staging | [size] | [count] | |

#### Database
| Service | Environment | Size | Storage | Cost/Month |
|---------|-------------|------|---------|------------|
| PostgreSQL | Production | [size] | [GB] | |
| Redis | Production | [size] | [GB] | |

#### Storage
| Service | Purpose | Estimated Size | Cost/Month |
|---------|---------|----------------|------------|
| S3 | File storage | [GB] | |

### Cost Estimate
| Category | Monthly Cost | Annual Cost |
|----------|--------------|-------------|
| Compute | | |
| Database | | |
| Storage | | |
| Network | | |
| **Total** | | |

### Environments
| Environment | Purpose | Data | Access |
|-------------|---------|------|--------|
| Development | Local dev | Synthetic | Developers |
| Staging | Pre-prod testing | Anonymized | Team |
| Production | Live users | Real | Restricted |

### Scaling Strategy
| Component | Scaling Type | Trigger | Min | Max |
|-----------|--------------|---------|-----|-----|
| API | Horizontal | CPU > 70% | 2 | 10 |
| Workers | Horizontal | Queue depth | 1 | 5 |
| Database | Vertical + Read replicas | Manual | | |

Step 8: Technical Specification Document
Compile complete technical spec:
markdownDownloadCopy code## Technical Specification Document

### Executive Summary
[2-3 paragraphs summarizing the technical approach]

### Architecture Overview
[Reference to diagrams]

### Key Technical Decisions
| Decision | Choice | Rationale |
|----------|--------|-----------|
| Language | | |
| Framework | | |
| Database | | |
| Hosting | | |
| Auth | | |

### Implementation Phases
| Phase | Focus | Technical Deliverables |
|-------|-------|------------------------|
| 1 | Foundation | Core API, DB schema, Auth |
| 2 | Features | Main functionality |
| 3 | Scale | Performance, monitoring |

### Technical Risks
| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| | | | |

### Open Technical Questions
| Question | Owner | Due Date |
|----------|-------|----------|
| | | |

### Appendix
- ADR Index
- Full API Specification
- Database Schema
- Infrastructure Diagrams
Outputs

1. Technical Requirements Analysis - Quality attributes and constraints
2. Architecture Decision Records (ADRs) - All key technical decisions documented
3. System Architecture Diagrams - C4 diagrams, data flow, deployment views
4. Data Architecture - Schema, storage strategy, backup plans
5. API Design - Endpoints, authentication, error handling
6. Security Architecture - Auth, authorization, data protection
7. Infrastructure Architecture - Cloud resources, scaling, cost estimates
8. Technical Specification Document - Comprehensive technical summary

Quality Gates
GateCriteriaStatusCompletenessAll PRD requirements have technical mappingFeasibilityTeam has reviewed and confirmed buildabilityScalabilityArchitecture handles 10x stated requirementsSecuritySecurity review completedCostInfrastructure costs within budgetDocumentationAll decisions documented with rationale
References & Best Practices
From The Pragmatic Engineer

* "Good architecture enables change; great architecture anticipates it."
* Document the WHY of decisions, not just the WHAT.

From Martin Fowler

* "The goal of software architecture is to minimize the human resources required to build and maintain the required system."
* Prefer evolutionary architecture over big upfront design.
* ADRs are essential for long-term maintainability.

From Toptal Engineering Blog

* "Every architectural decision is a trade-off. Document what you're trading away."
* Use C4 diagrams for consistent, zoom-able architecture views.

From Julia Evans

* "The best architecture diagrams tell a story, not just show boxes."
* Start with what you're trying to understand, then diagram.

From Stack Overflow Blog

* "The best architecture is the simplest one that solves the problem."
* Avoid resume-driven development—choose boring technology.

Invocation Examples
/technical-architecture prd="[link]" scale_requirements="10K DAU, 1M requests/day" tech_constraints="Node.js team, AWS preferred"

/technical-architecture compliance_requirements="SOC2, GDPR" integration_requirements="Stripe, Salesforce, Slack"
````
