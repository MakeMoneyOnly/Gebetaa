# SKILL: fullstack-integration

## Purpose

Integrate frontend and backend systems with secure authentication, end-to-end type safety, proper error handling, real-time capabilities, and seamless data flow. This skill ensures the entire stack works together cohesively as a unified, production-ready system.

## When to Use

- After `/frontend-engineering` and `/backend-engineering` are complete
- When implementing authentication and authorization flows
- When setting up API integration between client and server
- When establishing end-to-end type safety
- When implementing real-time features (WebSockets, SSE)
- When creating a unified error handling strategy

## Role Activated

**Staff Fullstack Engineer + Integration Architect**

You think like engineers at Vercel, Supabase, or Clerk—creating seamless experiences where frontend and backend feel like one unified system with zero friction at the boundaries.

## Inputs (Variables)

```yaml
{frontend_stack}: Next.js, React, React Query, Zustand
{backend_stack}: Node.js, Express/Fastify, Prisma
{auth_strategy}: Custom JWT, NextAuth, Clerk, Auth0
{api_style}: REST, GraphQL, tRPC
{realtime_needs}: WebSockets, Server-Sent Events, polling
{type_sharing}: Shared types package, tRPC, generated types
Step-by-Step Process
Step 1: End-to-End Type Safety Architecture
Establish type sharing between frontend and backend:
typescriptDownloadCopy code// Option 1: Shared Types Package
// packages/shared/src/types/index.ts

// ═══════════════════════════════════════════════════════════════
// ENTITY TYPES (Database models exposed to frontend)
// ═══════════════════════════════════════════════════════════════

export interface User {
  id: string;
  email: string;
  name: string | null;
  avatar: string | null;
  role: UserRole;
  createdAt: string; // ISO string for JSON serialization
  updatedAt: string;
}

export type UserRole = 'ADMIN' | 'MEMBER' | 'VIEWER';

export interface Project {
  id: string;
  name: string;
  slug: string;
  description: string | null;
  visibility: ProjectVisibility;
  ownerId: string;
  createdAt: string;
  updatedAt: string;
}

export type ProjectVisibility = 'PUBLIC' | 'PRIVATE';

export interface ProjectMember {
  id: string;
  userId: string;
  projectId: string;
  role: ProjectRole;
  user?: User;
  createdAt: string;
}

export type ProjectRole = 'OWNER' | 'ADMIN' | 'MEMBER' | 'VIEWER';

// ═══════════════════════════════════════════════════════════════
// API REQUEST TYPES
// ═══════════════════════════════════════════════════════════════

export interface CreateUserRequest {
  email: string;
  password: string;
  name: string;
}

export interface UpdateUserRequest {
  name?: string;
  avatar?: string;
}

export interface CreateProjectRequest {
  name: string;
  description?: string;
  visibility?: ProjectVisibility;
}

export interface UpdateProjectRequest {
  name?: string;
  description?: string;
  visibility?: ProjectVisibility;
}

export interface LoginRequest {
  email: string;
  password: string;
}

export interface RegisterRequest {
  email: string;
  password: string;
  name: string;
}

// ═══════════════════════════════════════════════════════════════
// API RESPONSE TYPES
// ═══════════════════════════════════════════════════════════════

export interface ApiSuccessResponse<T> {
  success: true;
  data: T;
  meta: {
    timestamp: string;
    requestId?: string;
  };
}

export interface ApiErrorResponse {
  success: false;
  error: {
    message: string;
    code: string;
    details?: unknown;
  };
  meta: {
    timestamp: string;
    requestId?: string;
  };
}

export type ApiResponse<T> = ApiSuccessResponse<T> | ApiErrorResponse;

export interface PaginatedResponse<T> {
  success: true;
  data: T[];
  meta: {
    timestamp: string;
    pagination: {
      total: number;
      page: number;
      limit: number;
      totalPages: number;
      hasMore: boolean;
    };
  };
}

export interface AuthResponse {
  user: User;
  accessToken: string;
  refreshToken?: string;
  expiresAt: string;
}

// ═══════════════════════════════════════════════════════════════
// QUERY PARAMETER TYPES
// ═══════════════════════════════════════════════════════════════

export interface PaginationParams {
  page?: number;
  limit?: number;
}

export interface ProjectsQueryParams extends PaginationParams {
  search?: string;
  visibility?: ProjectVisibility;
  sortBy?: 'name' | 'createdAt' | 'updatedAt';
  sortOrder?: 'asc' | 'desc';
}

export interface UsersQueryParams extends PaginationParams {
  search?: string;
  role?: UserRole;
}
typescriptDownloadCopy code// Option 2: tRPC for Full Type Safety (Recommended for new projects)
// packages/api/src/trpc/router.ts

import { initTRPC, TRPCError } from '@trpc/server';
import { z } from 'zod';
import superjson from 'superjson';

const t = initTRPC.context<Context>().create({
  transformer: superjson,
  errorFormatter({ shape, error }) {
    return {
      ...shape,
      data: {
        ...shape.data,
        zodError: error.cause instanceof z.ZodError ? error.cause.flatten() : null,
      },
    };
  },
});

export const router = t.router;
export const publicProcedure = t.procedure;
export const protectedProcedure = t.procedure.use(isAuthenticated);

// App Router
export const appRouter = router({
  // Auth
  auth: router({
    login: publicProcedure
      .input(z.object({
        email: z.string().email(),
        password: z.string().min(8),
      }))
      .mutation(async ({ input, ctx }) => {
        return ctx.authService.login(input.email, input.password);
      }),

    register: publicProcedure
      .input(z.object({
        email: z.string().email(),
        password: z.string().min(8),
        name: z.string().min(1).max(100),
      }))
      .mutation(async ({ input, ctx }) => {
        return ctx.authService.register(input);
      }),

    me: protectedProcedure.query(async ({ ctx }) => {
      return ctx.user;
    }),
  }),

  // Projects
  projects: router({
    list: protectedProcedure
      .input(z.object({
        page: z.number().min(1).default(1),
        limit: z.number().min(1).max(100).default(20),
        search: z.string().optional(),
      }))
      .query(async ({ input, ctx }) => {
        return ctx.projectService.findAll(ctx.user.id, input);
      }),

    byId: protectedProcedure
      .input(z.object({ id: z.string() }))
      .query(async ({ input, ctx }) => {
        const project = await ctx.projectService.findById(input.id);
        if (!project) {
          throw new TRPCError({ code: 'NOT_FOUND', message: 'Project not found' });
        }
        return project;
      }),

    create: protectedProcedure
      .input(z.object({
        name: z.string().min(1).max(100),
        description: z.string().max(500).optional(),
        visibility: z.enum(['PUBLIC', 'PRIVATE']).default('PRIVATE'),
      }))
      .mutation(async ({ input, ctx }) => {
        return ctx.projectService.create(ctx.user.id, input);
      }),

    update: protectedProcedure
      .input(z.object({
        id: z.string(),
        name: z.string().min(1).max(100).optional(),
        description: z.string().max(500).optional(),
        visibility: z.enum(['PUBLIC', 'PRIVATE']).optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        const { id, ...data } = input;
        return ctx.projectService.update(id, ctx.user.id, data);
      }),

    delete: protectedProcedure
      .input(z.object({ id: z.string() }))
      .mutation(async ({ input, ctx }) => {
        await ctx.projectService.delete(input.id, ctx.user.id);
        return { success: true };
      }),
  }),

  // Users
  users: router({
    list: protectedProcedure
      .input(z.object({
        page: z.number().min(1).default(1),
        limit: z.number().min(1).max(100).default(20),
        search: z.string().optional(),
      }))
      .query(async ({ input, ctx }) => {
        return ctx.userService.findAll(input);
      }),

    byId: protectedProcedure
      .input(z.object({ id: z.string() }))
      .query(async ({ input, ctx }) => {
        return ctx.userService.findById(input.id);
      }),

    update: protectedProcedure
      .input(z.object({
        name: z.string().min(1).max(100).optional(),
        avatar: z.string().url().optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        return ctx.userService.update(ctx.user.id, input);
      }),
  }),
});

export type AppRouter = typeof appRouter;
Step 2: Type-Safe API Client
Create a robust API client for REST APIs:
typescriptDownloadCopy code// frontend/lib/api-client.ts
import type {
  ApiResponse,
  ApiErrorResponse,
  PaginatedResponse,
  User,
  Project,
  AuthResponse,
  CreateProjectRequest,
  UpdateProjectRequest,
  ProjectsQueryParams,
  LoginRequest,
  RegisterRequest,
} from '@shared/types';

// ═══════════════════════════════════════════════════════════════
// API CLIENT ERROR
// ═══════════════════════════════════════════════════════════════

export class ApiClientError extends Error {
  constructor(
    message: string,
    public status: number,
    public code: string,
    public details?: unknown
  ) {
    super(message);
    this.name = 'ApiClientError';
  }

  static fromResponse(response: ApiErrorResponse, status: number): ApiClientError {
    return new ApiClientError(
      response.error.message,
      status,
      response.error.code,
      response.error.details
    );
  }
}

// ═══════════════════════════════════════════════════════════════
// API CLIENT CLASS
// ═══════════════════════════════════════════════════════════════

class ApiClient {
  private baseUrl: string;
  private accessToken: string | null = null;
  private refreshToken: string | null = null;
  private onUnauthorized?: () => void;

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
    this.loadTokens();
  }

  // Token Management
  private loadTokens() {
    if (typeof window !== 'undefined') {
      this.accessToken = localStorage.getItem('accessToken');
      this.refreshToken = localStorage.getItem('refreshToken');
    }
  }

  setTokens(accessToken: string, refreshToken?: string) {
    this.accessToken = accessToken;
    this.refreshToken = refreshToken || null;

    if (typeof window !== 'undefined') {
      localStorage.setItem('accessToken', accessToken);
      if (refreshToken) {
        localStorage.setItem('refreshToken', refreshToken);
      }
    }
  }

  clearTokens() {
    this.accessToken = null;
    this.refreshToken = null;

    if (typeof window !== 'undefined') {
      localStorage.removeItem('accessToken');
      localStorage.removeItem('refreshToken');
    }
  }

  setOnUnauthorized(callback: () => void) {
    this.onUnauthorized = callback;
  }

  // Core Request Method
  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const url = `${this.baseUrl}${endpoint}`;

    const headers: HeadersInit = {
      'Content-Type': 'application/json',
      ...options.headers,
    };

    if (this.accessToken) {
      (headers as Record<string, string>)['Authorization'] = `Bearer ${this.accessToken}`;
    }

    const response = await fetch(url, {
      ...options,
      headers,
      credentials: 'include',
    });

    // Handle 401 - try refresh token
    if (response.status === 401 && this.refreshToken) {
      const refreshed = await this.tryRefreshToken();
      if (refreshed) {
        // Retry original request
        (headers as Record<string, string>)['Authorization'] = `Bearer ${this.accessToken}`;
        const retryResponse = await fetch(url, { ...options, headers, credentials: 'include' });
        return this.handleResponse<T>(retryResponse);
      }
    }

    return this.handleResponse<T>(response);
  }

  private async handleResponse<T>(response: Response): Promise<T> {
    const data = await response.json();

    if (!response.ok) {
      if (response.status === 401) {
        this.clearTokens();
        this.onUnauthorized?.();
      }

      const errorResponse = data as ApiErrorResponse;
      throw ApiClientError.fromResponse(errorResponse, response.status);
    }

    // Return data directly (unwrap from success response)
    return (data as ApiResponse<T>).success ? (data as { data: T }).data : data;
  }

  private async tryRefreshToken(): Promise<boolean> {
    try {
      const response = await fetch(`${this.baseUrl}/auth/refresh`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ refreshToken: this.refreshToken }),
      });

      if (response.ok) {
        const data = await response.json();
        this.setTokens(data.data.accessToken, data.data.refreshToken);
        return true;
      }
    } catch {
      // Refresh failed
    }

    this.clearTokens();
    return false;
  }

  // Helper for query params
  private buildQueryString(params: Record<string, unknown>): string {
    const searchParams = new URLSearchParams();
    Object.entries(params).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        searchParams.append(key, String(value));
      }
    });
    const query = searchParams.toString();
    return query ? `?${query}` : '';
  }

  // ═══════════════════════════════════════════════════════════════
  // AUTH ENDPOINTS
  // ═══════════════════════════════════════════════════════════════

  async login(credentials: LoginRequest): Promise<AuthResponse> {
    const result = await this.request<AuthResponse>('/auth/login', {
      method: 'POST',
      body: JSON.stringify(credentials),
    });
    this.setTokens(result.accessToken, result.refreshToken);
    return result;
  }

  async register(data: RegisterRequest): Promise<AuthResponse> {
    const result = await this.request<AuthResponse>('/auth/register', {
      method: 'POST',
      body: JSON.stringify(data),
    });
    this.setTokens(result.accessToken, result.refreshToken);
    return result;
  }

  async logout(): Promise<void> {
    try {
      await this.request('/auth/logout', { method: 'POST' });
    } finally {
      this.clearTokens();
    }
  }

  async getMe(): Promise<User> {
    return this.request<User>('/auth/me');
  }

  async refreshTokens(): Promise<AuthResponse> {
    const result = await this.request<AuthResponse>('/auth/refresh', {
      method: 'POST',
      body: JSON.stringify({ refreshToken: this.refreshToken }),
    });
    this.setTokens(result.accessToken, result.refreshToken);
    return result;
  }

  // ═══════════════════════════════════════════════════════════════
  // PROJECT ENDPOINTS
  // ═══════════════════════════════════════════════════════════════

  async getProjects(params?: ProjectsQueryParams): Promise<PaginatedResponse<Project>> {
    const query = params ? this.buildQueryString(params) : '';
    return this.request<PaginatedResponse<Project>>(`/projects${query}`);
  }

  async getProject(id: string): Promise<Project> {
    return this.request<Project>(`/projects/${id}`);
  }

  async createProject(data: CreateProjectRequest): Promise<Project> {
    return this.request<Project>('/projects', {
      method: 'POST',
      body: JSON.stringify(data),
    });
  }

  async updateProject(id: string, data: UpdateProjectRequest): Promise<Project> {
    return this.request<Project>(`/projects/${id}`, {
      method: 'PATCH',
      body: JSON.stringify(data),
    });
  }

  async deleteProject(id: string): Promise<void> {
    await this.request(`/projects/${id}`, { method: 'DELETE' });
  }

  // ═══════════════════════════════════════════════════════════════
  // USER ENDPOINTS
  // ═══════════════════════════════════════════════════════════════

  async getUsers(params?: { page?: number; limit?: number; search?: string }) {
    const query = params ? this.buildQueryString(params) : '';
    return this.request<PaginatedResponse<User>>(`/users${query}`);
  }

  async getUser(id: string): Promise<User> {
    return this.request<User>(`/users/${id}`);
  }

  async updateUser(data: { name?: string; avatar?: string }): Promise<User> {
    return this.request<User>('/users/me', {
      method: 'PATCH',
      body: JSON.stringify(data),
    });
  }
}

// Export singleton instance
export const api = new ApiClient(process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001/api/v1');
Step 3: Authentication Context & Provider
Implement complete auth state management:
typescriptDownloadCopy code// frontend/lib/auth/auth-context.tsx
'use client';

import {
  createContext,
  useContext,
  useEffect,
  useState,
  useCallback,
  ReactNode,
} from 'react';
import { useRouter, usePathname } from 'next/navigation';
import { api, ApiClientError } from '@/lib/api-client';
import type { User, LoginRequest, RegisterRequest } from '@shared/types';

// ═══════════════════════════════════════════════════════════════
// TYPES
// ═══════════════════════════════════════════════════════════════

interface AuthState {
  user: User | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  error: string | null;
}

interface AuthContextValue extends AuthState {
  login: (credentials: LoginRequest) => Promise<void>;
  register: (data: RegisterRequest) => Promise<void>;
  logout: () => Promise<void>;
  clearError: () => void;
  refreshUser: () => Promise<void>;
}

// ═══════════════════════════════════════════════════════════════
// CONTEXT
// ═══════════════════════════════════════════════════════════════

const AuthContext = createContext<AuthContextValue | null>(null);

// ═══════════════════════════════════════════════════════════════
// PROVIDER
// ═══════════════════════════════════════════════════════════════

interface AuthProviderProps {
  children: ReactNode;
}

export function AuthProvider({ children }: AuthProviderProps) {
  const [state, setState] = useState<AuthState>({
    user: null,
    isLoading: true,
    isAuthenticated: false,
    error: null,
  });

  const router = useRouter();
  const pathname = usePathname();

  // Initialize auth state
  useEffect(() => {
    const initAuth = async () => {
      try {
        const user = await api.getMe();
        setState({
          user,
          isLoading: false,
          isAuthenticated: true,
          error: null,
        });
      } catch (error) {
        setState({
          user: null,
          isLoading: false,
          isAuthenticated: false,
          error: null,
        });
      }
    };

    initAuth();

    // Set up unauthorized handler
    api.setOnUnauthorized(() => {
      setState({
        user: null,
        isLoading: false,
        isAuthenticated: false,
        error: null,
      });
      router.push(`/login?redirect=${encodeURIComponent(pathname)}`);
    });
  }, [router, pathname]);

  // Login
  const login = useCallback(async (credentials: LoginRequest) => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      const { user } = await api.login(credentials);
      setState({
        user,
        isLoading: false,
        isAuthenticated: true,
        error: null,
      });

      // Redirect to intended destination or dashboard
      const params = new URLSearchParams(window.location.search);
      const redirect = params.get('redirect') || '/dashboard';
      router.push(redirect);
    } catch (error) {
      const message = error instanceof ApiClientError
        ? error.message
        : 'Login failed. Please try again.';

      setState(prev => ({
        ...prev,
        isLoading: false,
        error: message,
      }));
      throw error;
    }
  }, [router]);

  // Register
  const register = useCallback(async (data: RegisterRequest) => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      const { user } = await api.register(data);
      setState({
        user,
        isLoading: false,
        isAuthenticated: true,
        error: null,
      });
      router.push('/onboarding');
    } catch (error) {
      const message = error instanceof ApiClientError
        ? error.message
        : 'Registration failed. Please try again.';

      setState(prev => ({
        ...prev,
        isLoading: false,
        error: message,
      }));
      throw error;
    }
  }, [router]);

  // Logout
  const logout = useCallback(async () => {
    setState(prev => ({ ...prev, isLoading: true }));

    try {
      await api.logout();
    } finally {
      setState({
        user: null,
        isLoading: false,
        isAuthenticated: false,
        error: null,
      });
      router.push('/login');
    }
  }, [router]);

  // Refresh user data
  const refreshUser = useCallback(async () => {
    try {
      const user = await api.getMe();
      setState(prev => ({ ...prev, user }));
    } catch (error) {
      // Silently fail - user might be logged out
    }
  }, []);

  // Clear error
  const clearError = useCallback(() => {
    setState(prev => ({ ...prev, error: null }));
  }, []);

  const value: AuthContextValue = {
    ...state,
    login,
    register,
    logout,
    clearError,
    refreshUser,
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

// ═══════════════════════════════════════════════════════════════
// HOOKS
// ═══════════════════════════════════════════════════════════════

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

export function useUser() {
  const { user, isLoading } = useAuth();
  return { user, isLoading };
}

export function useRequireAuth() {
  const { isAuthenticated, isLoading } = useAuth();
  const router = useRouter();
  const pathname = usePathname();

  useEffect(() => {
    if (!isLoading && !isAuthenticated) {
      router.push(`/login?redirect=${encodeURIComponent(pathname)}`);
    }
  }, [isAuthenticated, isLoading, router, pathname]);

  return { isAuthenticated, isLoading };
}
Step 4: Protected Routes & Middleware
Implement route protection on both client and server:
typescriptDownloadCopy code// frontend/components/auth/protected-route.tsx
'use client';

import { useRequireAuth } from '@/lib/auth/auth-context';
import { LoadingScreen } from '@/components/ui/loading-screen';

interface ProtectedRouteProps {
  children: React.ReactNode;
  requiredRoles?: string[];
}

export function ProtectedRoute({ children, requiredRoles }: ProtectedRouteProps) {
  const { isAuthenticated, isLoading } = useRequireAuth();
  const { user } = useAuth();

  if (isLoading) {
    return <LoadingScreen />;
  }

  if (!isAuthenticated) {
    return null; // Will redirect via useRequireAuth
  }

  // Check role authorization
  if (requiredRoles && user && !requiredRoles.includes(user.role)) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <h1 className="text-2xl font-bold mb-2">Access Denied</h1>
          <p className="text-neutral-500">
            You don't have permission to access this page.
          </p>
        </div>
      </div>
    );
  }

  return <>{children}</>;
}

// Usage in layout
// app/(dashboard)/layout.tsx
export default function DashboardLayout({ children }: { children: React.ReactNode }) {
  return (
    <ProtectedRoute>
      <DashboardShell>{children}</DashboardShell>
    </ProtectedRoute>
  );
}
typescriptDownloadCopy code// frontend/middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { jwtVerify } from 'jose';

const PUBLIC_PATHS = ['/', '/login', '/register', '/forgot-password', '/reset-password'];
const AUTH_PATHS = ['/login', '/register'];
const PROTECTED_PATHS = ['/dashboard', '/projects', '/settings', '/admin'];
const ADMIN_PATHS = ['/admin'];

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  const token = request.cookies.get('accessToken')?.value;

  // Check if path matches any pattern
  const isPublicPath = PUBLIC_PATHS.some(p => pathname === p || pathname.startsWith(`${p}/`));
  const isAuthPath = AUTH_PATHS.some(p => pathname === p || pathname.startsWith(`${p}/`));
  const isProtectedPath = PROTECTED_PATHS.some(p => pathname === p || pathname.startsWith(`${p}/`));
  const isAdminPath = ADMIN_PATHS.some(p => pathname === p || pathname.startsWith(`${p}/`));

  // Verify token if present
  let user: { userId: string; role: string } | null = null;
  if (token) {
    try {
      const secret = new TextEncoder().encode(process.env.JWT_SECRET);
      const { payload } = await jwtVerify(token, secret);
      user = { userId: payload.userId as string, role: payload.role as string };
    } catch {
      // Invalid token - clear it
      const response = NextResponse.redirect(new URL('/login', request.url));
      response.cookies.delete('accessToken');
      return response;
    }
  }

  // Redirect authenticated users away from auth pages
  if (isAuthPath && user) {
    return NextResponse.redirect(new URL('/dashboard', request.url));
  }

  // Redirect unauthenticated users from protected pages
  if (isProtectedPath && !user) {
    const loginUrl = new URL('/login', request.url);
    loginUrl.searchParams.set('redirect', pathname);
    return NextResponse.redirect(loginUrl);
  }

  // Check admin access
  if (isAdminPath && user?.role !== 'ADMIN') {
    return NextResponse.redirect(new URL('/dashboard', request.url));
  }

  return NextResponse.next();
}

export const config = {
  matcher: [
    '/((?!api|_next/static|_next/image|favicon.ico|public).*)',
  ],
};
Step 5: React Query Integration
Set up data fetching with caching and synchronization:
typescriptDownloadCopy code// frontend/lib/query-client.ts
import { QueryClient, QueryCache, MutationCache } from '@tanstack/react-query';
import { toast } from 'sonner';
import { ApiClientError } from './api-client';

function handleError(error: unknown) {
  if (error instanceof ApiClientError) {
    switch (error.status) {
      case 401:
        // Handled by auth context
        break;
      case 403:
        toast.error('You do not have permission to perform this action');
        break;
      case 404:
        toast.error('The requested resource was not found');
        break;
      case 429:
        toast.error('Too many requests. Please slow down.');
        break;
      default:
        toast.error(error.message || 'An error occurred');
    }
  } else {
    toast.error('An unexpected error occurred');
    console.error('Unexpected error:', error);
  }
}

export const queryClient = new QueryClient({
  queryCache: new QueryCache({
    onError: (error, query) => {
      // Only show error toast if we haven't already handled it
      if (query.meta?.showErrorToast !== false) {
        handleError(error);
      }
    },
  }),
  mutationCache: new MutationCache({
    onError: (error, _variables, _context, mutation) => {
      if (mutation.meta?.showErrorToast !== false) {
        handleError(error);
      }
    },
  }),
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60, // 1 minute
      gcTime: 1000 * 60 * 5, // 5 minutes (formerly cacheTime)
      retry: (failureCount, error) => {
        // Don't retry on 4xx errors
        if (error instanceof ApiClientError && error.status < 500) {
          return false;
        }
        return failureCount < 2;
      },
      refetchOnWindowFocus: false,
    },
    mutations: {
      retry: false,
    },
  },
});
typescriptDownloadCopy code// frontend/hooks/use-projects.ts
import { useQuery, useMutation, useQueryClient, useInfiniteQuery } from '@tanstack/react-query';
import { api } from '@/lib/api-client';
import { toast } from 'sonner';
import type { Project, CreateProjectRequest, UpdateProjectRequest, ProjectsQueryParams } from '@shared/types';

// ═══════════════════════════════════════════════════════════════
// QUERY KEYS FACTORY
// ═══════════════════════════════════════════════════════════════

export const projectKeys = {
  all: ['projects'] as const,
  lists: () => [...projectKeys.all, 'list'] as const,
  list: (params: ProjectsQueryParams) => [...projectKeys.lists(), params] as const,
  details: () => [...projectKeys.all, 'detail'] as const,
  detail: (id: string) => [...projectKeys.details(), id] as const,
};

// ═══════════════════════════════════════════════════════════════
// QUERIES
// ═══════════════════════════════════════════════════════════════

export function useProjects(params: ProjectsQueryParams = {}) {
  return useQuery({
    queryKey: projectKeys.list(params),
    queryFn: () => api.getProjects(params),
  });
}

export function useInfiniteProjects(params: Omit<ProjectsQueryParams, 'page'> = {}) {
  return useInfiniteQuery({
    queryKey: projectKeys.list({ ...params, infinite: true }),
    queryFn: ({ pageParam = 1 }) => api.getProjects({ ...params, page: pageParam }),
    getNextPageParam: (lastPage) => {
      const { pagination } = lastPage.meta;
      return pagination.hasMore ? pagination.page + 1 : undefined;
    },
    initialPageParam: 1,
  });
}

export function useProject(id: string) {
  return useQuery({
    queryKey: projectKeys.detail(id),
    queryFn: () => api.getProject(id),
    enabled: !!id,
  });
}

// ═══════════════════════════════════════════════════════════════
// MUTATIONS
// ═══════════════════════════════════════════════════════════════

export function useCreateProject() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: CreateProjectRequest) => api.createProject(data),
    onSuccess: (newProject) => {
      // Invalidate all project lists
      queryClient.invalidateQueries({ queryKey: projectKeys.lists() });

      // Optionally, add to cache immediately
      queryClient.setQueryData(projectKeys.detail(newProject.id), newProject);

      toast.success('Project created successfully');
    },
    onError: () => {
      // Error handled by mutation cache
    },
  });
}

export function useUpdateProject() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateProjectRequest }) =>
      api.updateProject(id, data),
    onMutate: async ({ id, data }) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: projectKeys.detail(id) });

      // Snapshot previous value
      const previousProject = queryClient.getQueryData<Project>(projectKeys.detail(id));

      // Optimistically update
      if (previousProject) {
        queryClient.setQueryData(projectKeys.detail(id), {
          ...previousProject,
          ...data,
        });
      }

      return { previousProject };
    },
    onError: (err, { id }, context) => {
      // Rollback on error
      if (context?.previousProject) {
        queryClient.setQueryData(projectKeys.detail(id), context.previousProject);
      }
    },
    onSuccess: (updatedProject) => {
      // Update cache with server response
      queryClient.setQueryData(projectKeys.detail(updatedProject.id), updatedProject);
      queryClient.invalidateQueries({ queryKey: projectKeys.lists() });

      toast.success('Project updated');
    },
  });
}

export function useDeleteProject() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) => api.deleteProject(id),
    onMutate: async (id) => {
      await queryClient.cancelQueries({ queryKey: projectKeys.lists() });

      // Store for rollback
      const previousLists = queryClient.getQueriesData({ queryKey: projectKeys.lists() });

      // Optimistically remove from lists
      queryClient.setQueriesData(
        { queryKey: projectKeys.lists() },
        (old: any) => {
          if (!old?.data) return old;
          return {
            ...old,
            data: old.data.filter((p: Project) => p.id !== id),
          };
        }
      );

      return { previousLists };
    },
    onError: (err, id, context) => {
      // Rollback
      context?.previousLists.forEach(([queryKey, data]) => {
        queryClient.setQueryData(queryKey, data);
      });
    },
    onSuccess: (_, id) => {
      // Remove from detail cache
      queryClient.removeQueries({ queryKey: projectKeys.detail(id) });
      queryClient.invalidateQueries({ queryKey: projectKeys.lists() });

      toast.success('Project deleted');
    },
  });
}

// ═══════════════════════════════════════════════════════════════
// PREFETCHING
// ═══════════════════════════════════════════════════════════════

export function usePrefetchProject() {
  const queryClient = useQueryClient();

  return (id: string) => {
    queryClient.prefetchQuery({
      queryKey: projectKeys.detail(id),
      queryFn: () => api.getProject(id),
      staleTime: 1000 * 60, // 1 minute
    });
  };
}
Step 6: Real-Time Integration
Implement WebSocket support for real-time features:
typescriptDownloadCopy code// frontend/lib/realtime/socket-client.ts
import { io, Socket } from 'socket.io-client';
import { queryClient } from '@/lib/query-client';
import { projectKeys } from '@/hooks/use-projects';

type RealtimeEvent =
  | { type: 'project:created'; payload: { project: Project } }
  | { type: 'project:updated'; payload: { project: Project } }
  | { type: 'project:deleted'; payload: { projectId: string } }
  | { type: 'notification'; payload: { notification: Notification } };

class RealtimeClient {
  private socket: Socket | null = null;
  private listeners: Map<string, Set<(data: unknown) => void>> = new Map();

  connect(token: string) {
    if (this.socket?.connected) return;

    this.socket = io(process.env.NEXT_PUBLIC_WS_URL!, {
      auth: { token },
      transports: ['websocket'],
      reconnection: true,
      reconnectionAttempts: 5,
      reconnectionDelay: 1000,
    });

    this.socket.on('connect', () => {
      console.log('[Realtime] Connected');
    });

    this.socket.on('disconnect', (reason) => {
      console.log('[Realtime] Disconnected:', reason);
    });

    this.socket.on('error', (error) => {
      console.error('[Realtime] Error:', error);
    });

    // Handle incoming events
    this.socket.on('event', (event: RealtimeEvent) => {
      this.handleEvent(event);
    });
  }

  disconnect() {
    this.socket?.disconnect();
    this.socket = null;
  }

  private handleEvent(event: RealtimeEvent) {
    switch (event.type) {
      case 'project:created':
        queryClient.invalidateQueries({ queryKey: projectKeys.lists() });
        break;

      case 'project:updated':
        queryClient.setQueryData(
          projectKeys.detail(event.payload.project.id),
          event.payload.project
        );
        queryClient.invalidateQueries({ queryKey: projectKeys.lists() });
        break;

      case 'project:deleted':
        queryClient.removeQueries({
          queryKey: projectKeys.detail(event.payload.projectId)
        });
        queryClient.invalidateQueries({ queryKey: projectKeys.lists() });
        break;

      case 'notification':
        // Handle notification
        this.emit('notification', event.payload.notification);
        break;
    }

    // Notify any listeners
    this.emit(event.type, event.payload);
  }

  // Subscribe to events
  on(event: string, callback: (data: unknown) => void) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    this.listeners.get(event)!.add(callback);

    return () => {
      this.listeners.get(event)?.delete(callback);
    };
  }

  private emit(event: string, data: unknown) {
    this.listeners.get(event)?.forEach(callback => callback(data));
  }

  // Join a room (e.g., project room for collaboration)
  joinRoom(room: string) {
    this.socket?.emit('join', { room });
  }

  leaveRoom(room: string) {
    this.socket?.emit('leave', { room });
  }

  // Send a message
  send(event: string, data: unknown) {
    this.socket?.emit(event, data);
  }
}

export const realtime = new RealtimeClient();

// Hook for using realtime
// frontend/hooks/use-realtime.ts
import { useEffect } from 'react';
import { useAuth } from '@/lib/auth/auth-context';
import { realtime } from '@/lib/realtime/socket-client';

export function useRealtime() {
  const { isAuthenticated, user } = useAuth();

  useEffect(() => {
    if (isAuthenticated && user) {
      const token = localStorage.getItem('accessToken');
      if (token) {
        realtime.connect(token);
      }
    } else {
      realtime.disconnect();
    }

    return () => {
      realtime.disconnect();
    };
  }, [isAuthenticated, user]);
}

export function useRealtimeRoom(room: string | undefined) {
  useEffect(() => {
    if (room) {
      realtime.joinRoom(room);
      return () => realtime.leaveRoom(room);
    }
  }, [room]);
}

export function useRealtimeEvent<T>(event: string, callback: (data: T) => void) {
  useEffect(() => {
    return realtime.on(event, callback as (data: unknown) => void);
  }, [event, callback]);
}
Step 7: Server-Side Data Fetching
For Next.js App Router server components:
typescriptDownloadCopy code// frontend/lib/server-api.ts
import { cookies } from 'next/headers';
import type { User, Project } from '@shared/types';

const API_URL = process.env.API_URL || 'http://localhost:3001/api/v1';

async function serverFetch<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
  const cookieStore = cookies();
  const token = cookieStore.get('accessToken')?.value;

  const response = await fetch(`${API_URL}${endpoint}`, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...(token && { Authorization: `Bearer ${token}` }),
      ...options.headers,
    },
    // Important: Configure caching
    next: {
      revalidate: 60, // Revalidate every 60 seconds
      tags: [endpoint], // For on-demand revalidation
    },
  });

  if (!response.ok) {
    throw new Error(`API Error: ${response.status}`);
  }

  const data = await response.json();
  return data.data;
}

// Server-side API functions
export const serverApi = {
  getMe: () => serverFetch<User>('/auth/me'),

  getProjects: (params?: { page?: number; limit?: number }) => {
    const query = new URLSearchParams(params as Record<string, string>).toString();
    return serverFetch<Project[]>(`/projects${query ? `?${query}` : ''}`);
  },

  getProject: (id: string) => serverFetch<Project>(`/projects/${id}`),
};

// Usage in Server Component
// app/(dashboard)/projects/page.tsx
import { Suspense } from 'react';
import { serverApi } from '@/lib/server-api';
import { ProjectList } from './project-list';
import { ProjectListSkeleton } from './project-list-skeleton';

export default async function ProjectsPage() {
  return (
    <div className="container py-8">
      <h1 className="text-3xl font-bold mb-8">Projects</h1>
      <Suspense fallback={<ProjectListSkeleton />}>
        <ProjectListLoader />
      </Suspense>
    </div>
  );
}

async function ProjectListLoader() {
  const projects = await serverApi.getProjects();
  return <ProjectList initialData={projects} />;
}
Step 8: Form Handling Integration
Complete form handling with validation:
typescriptDownloadCopy code// frontend/components/features/projects/create-project-form.tsx
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useCreateProject } from '@/hooks/use-projects';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Select } from '@/components/ui/select';
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from '@/components/ui/form';

const createProjectSchema = z.object({
  name: z
    .string()
    .min(1, 'Name is required')
    .max(100, 'Name must be less than 100 characters'),
  description: z
    .string()
    .max(500, 'Description must be less than 500 characters')
    .optional(),
  visibility: z.enum(['PUBLIC', 'PRIVATE']).default('PRIVATE'),
});

type CreateProjectFormValues = z.infer<typeof createProjectSchema>;

interface CreateProjectFormProps {
  onSuccess?: () => void;
  onCancel?: () => void;
}

export function CreateProjectForm({ onSuccess, onCancel }: CreateProjectFormProps) {
  const createProject = useCreateProject();

  const form = useForm<CreateProjectFormValues>({
    resolver: zodResolver(createProjectSchema),
    defaultValues: {
      name: '',
      description: '',
      visibility: 'PRIVATE',
    },
  });

  const onSubmit = async (data: CreateProjectFormValues) => {
    try {
      await createProject.mutateAsync(data);
      form.reset();
      onSuccess?.();
    } catch (error) {
      // Error handled by mutation
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Project Name</FormLabel>
              <FormControl>
                <Input placeholder="My Awesome Project" {...field} />
              </FormControl>
              <FormDescription>
                Choose a memorable name for your project.
              </FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="description"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Description</FormLabel>
              <FormControl>
                <Textarea
                  placeholder="What is this project about?"
                  rows={3}
                  {...field}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="visibility"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Visibility</FormLabel>
              <Select
                onValueChange={field.onChange}
                defaultValue={field.value}
              >
                <FormControl>
                  <SelectTrigger>
                    <SelectValue placeholder="Select visibility" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  <SelectItem value="PRIVATE">
                    <div className="flex items-center">
                      <LockIcon className="mr-2 h-4 w-4" />
                      Private
                    </div>
                  </SelectItem>
                  <SelectItem value="PUBLIC">
                    <div className="flex items-center">
                      <GlobeIcon className="mr-2 h-4 w-4" />
                      Public
                    </div>
                  </SelectItem>
                </SelectContent>
              </Select>
              <FormDescription>
                Private projects are only visible to you and invited members.
              </FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />

        <div className="flex justify-end gap-3">
          {onCancel && (
            <Button type="button" variant="ghost" onClick={onCancel}>
              Cancel
            </Button>
          )}
          <Button type="submit" loading={createProject.isPending}>
            Create Project
          </Button>
        </div>
      </form>
    </Form>
  );
}
Outputs

1. Shared Types Package - End-to-end type safety
2. Type-Safe API Client - Full error handling, token refresh
3. Authentication System - Context, provider, hooks
4. Route Protection - Client & server middleware
5. React Query Setup - Caching, optimistic updates, prefetching
6. Real-time System - WebSocket integration with query invalidation
7. Server Components - SSR data fetching patterns
8. Form Integration - Complete form handling with validation

Quality Gates
GateCriteriaStatusType SafetyZero any types in integration layerAuth SecurityTokens handled securely, refresh worksError HandlingAll errors show appropriate user feedbackLoading StatesAll async operations have loading indicatorsOptimistic UpdatesCritical mutations update UI instantlyReal-timeWebSocket reconnection works reliablySSRServer components fetch data correctly
References & Best Practices
From The Pragmatic Engineer

* "The best integrations are invisible to the user but obvious to developers."
* Type safety at API boundaries prevents entire classes of bugs.

From Vercel/Next.js

* Server Components for initial data, Client Components for interactivity.
* Use React Query for client-side cache management.

From tRPC Team

* "End-to-end type safety eliminates API documentation drift entirely."
* Zod for runtime validation that matches TypeScript types.

From TanStack Query

* "Server state is different from client state—treat it accordingly."
* Optimistic updates create perceived performance.

Invocation Examples
/fullstack-integration frontend_stack="Next.js 14, React Query" backend_stack="Node.js, Express, Prisma" auth_strategy="Custom JWT"

/fullstack-integration api_style="tRPC" realtime_needs="WebSockets for collaboration"
```
