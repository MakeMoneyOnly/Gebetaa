# SKILL: frontend-engineering

## Purpose

Architect and implement production-grade frontend applications with modern best practices, optimal performance, and maintainable code structure. This skill covers everything from project setup to deployment-ready code.

## When to Use

- After design system, components, and motion are defined
- When starting frontend implementation
- When establishing frontend architecture patterns
- When optimizing existing frontend codebases
- When setting up new frontend projects

## Role Activated

**Principal Frontend Engineer + Performance Architect**

You think like the frontend leads at Vercel, Netflix, or Airbnb—building applications that are fast, accessible, maintainable, and delightful.

## Inputs (Variables)

````yaml
{prd}: Product requirements
{design_system}: From /design-system-core
{components}: From /component-architecture
{framework}: Next.js, Remix, Astro, SvelteKit
{styling}: Tailwind, CSS Modules, styled-components
{state_management}: React Query, Zustand, Jotai
{api_type}: REST, GraphQL, tRPC
Step-by-Step Process
Step 1: Project Architecture
Define scalable project structure:
markdownDownloadCopy code## Frontend Project Architecture

### Recommended Stack (2026)

| Layer | Technology | Rationale |
|-------|------------|-----------|
| Framework | Next.js 15+ | RSC, App Router, optimal DX |
| Styling | Tailwind CSS 4 | Design tokens, performance |
| Components | Radix + Custom | Accessible primitives |
| State | Zustand + React Query | Simple, powerful, cached |
| Forms | React Hook Form + Zod | Validation, performance |
| Animation | Framer Motion | Declarative, powerful |
| Testing | Vitest + Playwright | Fast, reliable |

### Project Structure

src/
├── app/                    # Next.js App Router
│   ├── (auth)/            # Route groups
│   │   ├── login/
│   │   └── register/
│   ├── (dashboard)/
│   │   ├── layout.tsx
│   │   ├── page.tsx
│   │   └── projects/
│   ├── api/               # API routes
│   ├── layout.tsx         # Root layout
│   └── globals.css
│
├── components/
│   ├── ui/                # Design system components
│   │   ├── button.tsx
│   │   ├── input.tsx
│   │   └── index.ts
│   ├── features/          # Feature-specific components
│   │   ├── projects/
│   │   └── settings/
│   └── layouts/           # Layout components
│       ├── dashboard-layout.tsx
│       └── auth-layout.tsx
│
├── lib/                   # Utilities and configs
│   ├── utils.ts          # Helper functions
│   ├── api.ts            # API client
│   ├── auth.ts           # Auth utilities
│   └── constants.ts
│
├── hooks/                 # Custom React hooks
│   ├── use-user.ts
│   ├── use-projects.ts
│   └── use-media-query.ts
│
├── stores/                # State management
│   ├── user-store.ts
│   └── ui-store.ts
│
├── types/                 # TypeScript types
│   ├── api.ts
│   ├── models.ts
│   └── index.ts
│
├── styles/                # Global styles
│   └── tokens.css
│
└── config/                # Configuration
├── site.ts
└── navigation.ts

### File Naming Conventions

| Type | Convention | Example |
|------|------------|---------|
| Components | PascalCase | `Button.tsx` |
| Hooks | camelCase, use- prefix | `use-user.ts` |
| Utilities | camelCase | `formatDate.ts` |
| Types | PascalCase | `User.ts` |
| Constants | SCREAMING_SNAKE | `API_URL` |
| CSS Modules | kebab-case | `button.module.css` |

Step 2: Configuration & Setup
Establish project configuration:
markdownDownloadCopy code## Project Configuration

### TypeScript Configuration

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["dom", "dom.iterable", "ES2022"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [{ "name": "next" }],
    "paths": {
      "@/*": ["./src/*"],
      "@/components/*": ["./src/components/*"],
      "@/lib/*": ["./src/lib/*"],
      "@/hooks/*": ["./src/hooks/*"],
      "@/types/*": ["./src/types/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
Tailwind Configuration
javascriptDownloadCopy code// tailwind.config.ts
import type { Config } from 'tailwindcss';

const config: Config = {
  darkMode: ['class', '[data-theme="dark"]'],
  content: ['./src/**/*.{js,ts,jsx,tsx,mdx}'],
  theme: {
    extend: {
      colors: {
        // Map to CSS variables from design system
        primary: {
          50: 'var(--color-primary-50)',
          100: 'var(--color-primary-100)',
          // ... etc
        },
        neutral: {
          // ... neutral scale
        },
      },
      spacing: {
        // Use design system spacing
      },
      borderRadius: {
        button: 'var(--radius-button)',
        card: 'var(--radius-card)',
        modal: 'var(--radius-modal)',
      },
      fontFamily: {
        sans: ['var(--font-family-sans)'],
        heading: ['var(--font-family-heading)'],
        mono: ['var(--font-family-mono)'],
      },
      animation: {
        'fade-in': 'fadeIn 0.3s ease-out',
        'slide-up': 'slideUp 0.3s ease-out',
        'spin-slow': 'spin 2s linear infinite',
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        slideUp: {
          '0%': { opacity: '0', transform: 'translateY(10px)' },
          '100%': { opacity: '1', transform: 'translateY(0)' },
        },
      },
    },
  },
  plugins: [
    require('@tailwindcss/typography'),
    require('@tailwindcss/forms'),
    require('tailwindcss-animate'),
  ],
};

export default config;
ESLint Configuration
javascriptDownloadCopy code// eslint.config.js
import js from '@eslint/js';
import typescript from '@typescript-eslint/eslint-plugin';
import react from 'eslint-plugin-react';
import reactHooks from 'eslint-plugin-react-hooks';
import a11y from 'eslint-plugin-jsx-a11y';
import prettier from 'eslint-config-prettier';

export default [
  js.configs.recommended,
  {
    files: ['**/*.{ts,tsx}'],
    plugins: {
      '@typescript-eslint': typescript,
      'react': react,
      'react-hooks': reactHooks,
      'jsx-a11y': a11y,
    },
    rules: {
      // TypeScript
      '@typescript-eslint/no-unused-vars': 'error',
      '@typescript-eslint/no-explicit-any': 'warn',

      // React
      'react/prop-types': 'off',
      'react/react-in-jsx-scope': 'off',
      'react-hooks/rules-of-hooks': 'error',
      'react-hooks/exhaustive-deps': 'warn',

      // Accessibility
      'jsx-a11y/alt-text': 'error',
      'jsx-a11y/anchor-is-valid': 'error',
      'jsx-a11y/click-events-have-key-events': 'error',
    },
  },
  prettier,
];

### Step 3: Data Fetching Patterns

Implement data layer:

```markdown
## Data Fetching Architecture

### API Client Setup

```typescript
// lib/api.ts
import { z } from 'zod';

const API_BASE = process.env.NEXT_PUBLIC_API_URL;

class APIError extends Error {
  constructor(
    message: string,
    public status: number,
    public code?: string
  ) {
    super(message);
    this.name = 'APIError';
  }
}

async function fetcher<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  const url = `${API_BASE}${endpoint}`;

  const response = await fetch(url, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new APIError(
      error.message || 'An error occurred',
      response.status,
      error.code
    );
  }

  return response.json();
}

export const api = {
  get: <T>(endpoint: string) => fetcher<T>(endpoint),
  post: <T>(endpoint: string, data: unknown) =>
    fetcher<T>(endpoint, {
      method: 'POST',
      body: JSON.stringify(data),
    }),
  put: <T>(endpoint: string, data: unknown) =>
    fetcher<T>(endpoint, {
      method: 'PUT',
      body: JSON.stringify(data),
    }),
  delete: <T>(endpoint: string) =>
    fetcher<T>(endpoint, { method: 'DELETE' }),
};

React Query Setup
typescriptDownloadCopy code// lib/query-client.ts
import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 60 * 1000, // 1 minute
      gcTime: 5 * 60 * 1000, // 5 minutes (formerly cacheTime)
      retry: 1,
      refetchOnWindowFocus: false,
    },
  },
});

// hooks/use-projects.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { api } from '@/lib/api';
import type { Project } from '@/types';

export const projectKeys = {
  all: ['projects'] as const,
  lists: () => [...projectKeys.all, 'list'] as const,
  list: (filters: string) => [...projectKeys.lists(), { filters }] as const,
  details: () => [...projectKeys.all, 'detail'] as const,
  detail: (id: string) => [...projectKeys.details(), id] as const,
};

export function useProjects() {
  return useQuery({
    queryKey: projectKeys.lists(),
    queryFn: () => api.get<Project[]>('/projects'),
  });
}

export function useProject(id: string) {
  return useQuery({
    queryKey: projectKeys.detail(id),
    queryFn: () => api.get<Project>(`/projects/${id}`),
    enabled: !!id,
  });
}

export function useCreateProject() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: CreateProjectInput) =>
      api.post<Project>('/projects', data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: projectKeys.lists() });
    },
  });
}
Server Components Data Fetching
typescriptDownloadCopy code// app/(dashboard)/projects/page.tsx
import { Suspense } from 'react';
import { ProjectList } from '@/components/features/projects/project-list';
import { ProjectListSkeleton } from '@/components/features/projects/project-list-skeleton';

async function getProjects() {
  const res = await fetch(`${process.env.API_URL}/projects`, {
    next: { revalidate: 60 }, // ISR: revalidate every 60 seconds
  });

  if (!res.ok) throw new Error('Failed to fetch projects');
  return res.json();
}

export default async function ProjectsPage() {
  return (
    <div className="container py-8">
      <h1 className="text-3xl font-bold mb-8">Projects</h1>
      <Suspense fallback={<ProjectListSkeleton />}>
        <ProjectListContent />
      </Suspense>
    </div>
  );
}

async function ProjectListContent() {
  const projects = await getProjects();
  return <ProjectList projects={projects} />;
}

### Step 4: State Management

Implement global state:

```markdown
## State Management

### Zustand Store

```typescript
// stores/user-store.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface User {
  id: string;
  email: string;
  name: string;
  avatar?: string;
}

interface UserState {
  user: User | null;
  isAuthenticated: boolean;
  setUser: (user: User | null) => void;
  logout: () => void;
}

export const useUserStore = create<UserState>()(
  persist(
    (set) => ({
      user: null,
      isAuthenticated: false,
      setUser: (user) =>
        set({ user, isAuthenticated: !!user }),
      logout: () =>
        set({ user: null, isAuthenticated: false }),
    }),
    {
      name: 'user-storage',
      partialize: (state) => ({ user: state.user }),
    }
  )
);

// stores/ui-store.ts
import { create } from 'zustand';

interface UIState {
  sidebarOpen: boolean;
  theme: 'light' | 'dark' | 'system';
  toggleSidebar: () => void;
  setSidebarOpen: (open: boolean) => void;
  setTheme: (theme: 'light' | 'dark' | 'system') => void;
}

export const useUIStore = create<UIState>((set) => ({
  sidebarOpen: true,
  theme: 'system',
  toggleSidebar: () =>
    set((state) => ({ sidebarOpen: !state.sidebarOpen })),
  setSidebarOpen: (open) => set({ sidebarOpen: open }),
  setTheme: (theme) => set({ theme }),
}));

Form State with React Hook Form
typescriptDownloadCopy code// components/features/projects/create-project-form.tsx
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { useCreateProject } from '@/hooks/use-projects';

const createProjectSchema = z.object({
  name: z.string().min(1, 'Name is required').max(100),
  description: z.string().max(500).optional(),
  visibility: z.enum(['private', 'public']),
});

type CreateProjectInput = z.infer<typeof createProjectSchema>;

export function CreateProjectForm({ onSuccess }: { onSuccess?: () => void }) {
  const createProject = useCreateProject();

  const form = useForm<CreateProjectInput>({
    resolver: zodResolver(createProjectSchema),
    defaultValues: {
      name: '',
      description: '',
      visibility: 'private',
    },
  });

  const onSubmit = async (data: CreateProjectInput) => {
    try {
      await createProject.mutateAsync(data);
      form.reset();
      onSuccess?.();
    } catch (error) {
      // Handle error
    }
  };

  return (
    <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
      <div>
        <label htmlFor="name" className="text-sm font-medium">
          Project Name
        </label>
        <Input
          id="name"
          {...form.register('name')}
          error={!!form.formState.errors.name}
        />
        {form.formState.errors.name && (
          <p className="text-sm text-red-500 mt-1">
            {form.formState.errors.name.message}
          </p>
        )}
      </div>

      <Button
        type="submit"
        loading={createProject.isPending}
      >
        Create Project
      </Button>
    </form>
  );
}

### Step 5: Performance Optimization

Implement performance patterns:

```markdown
## Performance Optimization

### Code Splitting

```typescript
// Lazy load heavy components
import dynamic from 'next/dynamic';

const HeavyChart = dynamic(
  () => import('@/components/features/analytics/chart'),
  {
    loading: () => <ChartSkeleton />,
    ssr: false, // Disable SSR for client-only components
  }
);

const MarkdownEditor = dynamic(
  () => import('@/components/ui/markdown-editor'),
  { loading: () => <EditorSkeleton /> }
);

Image Optimization
typescriptDownloadCopy code// components/ui/optimized-image.tsx
import Image from 'next/image';

interface OptimizedImageProps {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  priority?: boolean;
  className?: string;
}

export function OptimizedImage({
  src,
  alt,
  width,
  height,
  priority = false,
  className,
}: OptimizedImageProps) {
  return (
    <Image
      src={src}
      alt={alt}
      width={width}
      height={height}
      priority={priority}
      className={className}
      placeholder="blur"
      blurDataURL="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBD..."
      sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
    />
  );
}
Memoization Patterns
typescriptDownloadCopy code// Memoize expensive computations
import { useMemo, useCallback, memo } from 'react';

// Memoize component
export const ExpensiveList = memo(function ExpensiveList({
  items
}: {
  items: Item[]
}) {
  return (
    <ul>
      {items.map((item) => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
});

// Memoize values
function Dashboard({ data }: { data: DashboardData }) {
  const processedData = useMemo(
    () => expensiveProcess(data),
    [data]
  );

  const handleAction = useCallback((id: string) => {
    // Handle action
  }, []);

  return <DashboardView data={processedData} onAction={handleAction} />;
}
Bundle Analysis
javascriptDownloadCopy code// next.config.js
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
});

module.exports = withBundleAnalyzer({
  // config
});

### Step 6: Error Handling

Implement error boundaries:

```markdown
## Error Handling

### Error Boundary Component

```typescript
// components/error-boundary.tsx
'use client';

import { Component, ReactNode } from 'react';
import { Button } from '@/components/ui/button';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
    // Send to error tracking service
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="flex flex-col items-center justify-center p-8">
          <h2 className="text-xl font-semibold mb-2">Something went wrong</h2>
          <p className="text-neutral-500 mb-4">
            We're sorry, but something unexpected happened.
          </p>
          <Button onClick={() => this.setState({ hasError: false })}>
            Try again
          </Button>
        </div>
      );
    }

    return this.props.children;
  }
}

// Next.js App Router error.tsx
// app/(dashboard)/error.tsx
'use client';

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  return (
    <div className="flex flex-col items-center justify-center min-h-[400px]">
      <h2 className="text-xl font-semibold mb-2">Something went wrong</h2>
      <Button onClick={() => reset()}>Try again</Button>
    </div>
  );
}


## Outputs

1. **Project Architecture** - Scalable folder structure
2. **Configuration Files** - TypeScript, Tailwind, ESLint
3. **Data Fetching Layer** - API client, React Query setup
4. **State Management** - Zustand stores, form handling
5. **Performance Patterns** - Code splitting, memoization
6. **Error Handling** - Error boundaries, error pages
7. **Testing Setup** - Unit and integration test structure

## Quality Gates

| Gate | Criteria | Status |
|------|----------|--------|
| TypeScript | Strict mode, no any types | |
| Performance | LCP < 2.5s, FID < 100ms, CLS < 0.1 | |
| Accessibility | Lighthouse a11y score > 95 | |
| Bundle Size | Initial JS < 100KB gzipped | |
| Test Coverage | > 80% for critical paths | |
| Error Handling | All async operations have error handling | |

## References & Best Practices

### From The Pragmatic Engineer
- "The best frontend architectures make the right thing easy and the wrong thing hard."
- File structure should reflect feature boundaries.

### From Martin Fowler
- "Any fool can write code that a computer can understand. Good programmers write code that humans can understand."

### From Vercel/Next.js Team
- Server Components for data fetching, Client Components for interactivity.
- Use the App Router for modern patterns.

## Invocation Examples


/frontend-engineering framework="Next.js 15" styling="Tailwind" state_management="Zustand + React Query"
````
