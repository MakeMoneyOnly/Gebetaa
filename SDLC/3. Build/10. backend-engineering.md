# SKILL: backend-engineering

## Purpose

Design and implement production-grade backend systems including APIs, databases, authentication, and business logic. This skill covers architecture patterns, security best practices, and scalable implementations.

## When to Use

- After technical architecture is defined
- When building API services
- When designing database schemas
- When implementing authentication/authorization
- When establishing backend patterns for a team

## Role Activated

**Principal Backend Engineer + Systems Architect**

You think like senior engineers at Stripe, Discord, or Cloudflare—building systems that are secure, scalable, and maintainable.

## Inputs (Variables)

````yaml
{prd}: Product requirements
{technical_architecture}: From /technical-architecture
{api_design}: API specifications
{data_model}: Entity relationships
{scale_requirements}: Expected load
{language}: Node.js, Python, Go, Rust
{database}: PostgreSQL, MySQL, MongoDB
Step-by-Step Process
Step 1: Project Structure
src/
├── api/                    # API layer
│   ├── routes/            # Route definitions
│   ├── controllers/       # Request handlers
│   ├── middleware/        # Express middleware
│   └── validators/        # Request validation
├── services/              # Business logic
├── repositories/          # Data access
├── models/                # Database models
├── lib/                   # Utilities
├── types/                 # TypeScript types
├── config/                # Configuration
├── jobs/                  # Background jobs
└── tests/                 # Tests

Step 2: API Implementation
typescriptDownloadCopy code// src/app.ts
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import compression from 'compression';
import { rateLimit } from 'express-rate-limit';
import { errorHandler } from './api/middleware/error.middleware';
import routes from './api/routes';

const app = express();

// Security middleware
app.use(helmet());
app.use(cors({ origin: process.env.CORS_ORIGIN?.split(','), credentials: true }));
app.use(rateLimit({ windowMs: 15 * 60 * 1000, max: 100 }));

// Body parsing
app.use(express.json({ limit: '10mb' }));
app.use(compression());

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'healthy', timestamp: new Date().toISOString() });
});

// API routes
app.use('/api/v1', routes);

// Error handling
app.use(errorHandler);

export default app;
Step 3: Service Layer Pattern
typescriptDownloadCopy code// src/services/users.service.ts
import { UsersRepository } from '@/repositories/users.repository';
import { CreateUserDto, UpdateUserDto } from '@/types';
import { AppError } from '@/lib/errors';
import { EventEmitter } from '@/lib/events';

export class UsersService {
  constructor(
    private usersRepository: UsersRepository,
    private eventEmitter: EventEmitter
  ) {}

  async findAll(options: PaginationOptions) {
    return this.usersRepository.findAll(options);
  }

  async findById(id: string) {
    const user = await this.usersRepository.findById(id);
    if (!user) {
      throw new AppError('User not found', 404, 'USER_NOT_FOUND');
    }
    return user;
  }

  async create(data: CreateUserDto) {
    const existingUser = await this.usersRepository.findByEmail(data.email);
    if (existingUser) {
      throw new AppError('Email already registered', 400, 'EMAIL_EXISTS');
    }

    const user = await this.usersRepository.create(data);

    // Emit event for side effects
    this.eventEmitter.emit('user.created', { user });

    return user;
  }

  async update(id: string, data: UpdateUserDto) {
    await this.findById(id); // Ensure exists
    return this.usersRepository.update(id, data);
  }

  async delete(id: string) {
    await this.findById(id);
    await this.usersRepository.delete(id);
    this.eventEmitter.emit('user.deleted', { userId: id });
  }
}
Step 4: Database Layer (Prisma)
prismaDownloadCopy code// prisma/schema.prisma
model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  passwordHash  String    @map("password_hash")
  role          Role      @default(MEMBER)
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")
  deletedAt     DateTime? @map("deleted_at")

  projects      ProjectMember[]
  sessions      Session[]

  @@index([email])
  @@map("users")
}

model Project {
  id          String     @id @default(cuid())
  name        String
  slug        String     @unique
  description String?
  visibility  Visibility @default(PRIVATE)
  createdAt   DateTime   @default(now()) @map("created_at")
  updatedAt   DateTime   @updatedAt @map("updated_at")

  members     ProjectMember[]

  @@map("projects")
}

enum Role {
  ADMIN
  MEMBER
}

enum Visibility {
  PUBLIC
  PRIVATE
}
Step 5: Authentication
typescriptDownloadCopy code// src/lib/auth.ts
import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';

export const auth = {
  hashPassword: (password: string) => bcrypt.hash(password, 12),
  verifyPassword: (password: string, hash: string) => bcrypt.compare(password, hash),

  generateToken: (user: User): string => {
    return jwt.sign(
      { userId: user.id, email: user.email, role: user.role },
      process.env.JWT_SECRET!,
      { expiresIn: '7d' }
    );
  },

  verifyToken: (token: string) => {
    return jwt.verify(token, process.env.JWT_SECRET!) as JWTPayload;
  },
};

// src/api/middleware/auth.middleware.ts
export const authenticate = (req: Request, res: Response, next: NextFunction) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');
    if (!token) return ApiResponse.unauthorized(res);

    req.user = auth.verifyToken(token);
    next();
  } catch {
    return ApiResponse.unauthorized(res, 'Invalid token');
  }
};

export const authorize = (...roles: string[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!roles.includes(req.user?.role)) {
      return ApiResponse.forbidden(res);
    }
    next();
  };
};
Step 6: Error Handling
typescriptDownloadCopy code// src/lib/errors.ts
export class AppError extends Error {
  constructor(
    message: string,
    public statusCode: number = 500,
    public code?: string,
    public details?: unknown
  ) {
    super(message);
    this.name = 'AppError';
  }
}

// src/api/middleware/error.middleware.ts
import { logger } from '@/lib/logger';

export const errorHandler = (
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  logger.error('Error:', {
    message: err.message,
    stack: err.stack,
    path: req.path,
    method: req.method,
  });

  if (err instanceof AppError) {
    return res.status(err.statusCode).json({
      success: false,
      error: {
        message: err.message,
        code: err.code,
        details: err.details,
      },
    });
  }

  // Prisma errors
  if (err.name === 'PrismaClientKnownRequestError') {
    return res.status(400).json({
      success: false,
      error: { message: 'Database error', code: 'DATABASE_ERROR' },
    });
  }

  // Default error
  return res.status(500).json({
    success: false,
    error: { message: 'Internal server error', code: 'INTERNAL_ERROR' },
  });
};
Step 7: Background Jobs
typescriptDownloadCopy code// src/lib/queue.ts
import { Queue, Worker } from 'bullmq';
import Redis from 'ioredis';

const connection = new Redis(process.env.REDIS_URL!);

export const emailQueue = new Queue('email', { connection });

export const emailWorker = new Worker(
  'email',
  async (job) => {
    const { to, subject, template, data } = job.data;
    await sendEmail({ to, subject, template, data });
  },
  { connection, concurrency: 5 }
);

// Usage
await emailQueue.add('welcome', {
  to: user.email,
  subject: 'Welcome!',
  template: 'welcome',
  data: { name: user.name },
});
Step 8: Input Validation
typescriptDownloadCopy code// src/api/validators/users.validator.ts
import { z } from 'zod';

export const createUserSchema = z.object({
  email: z.string().email('Invalid email'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
  name: z.string().min(1).max(100),
});

export const updateUserSchema = z.object({
  name: z.string().min(1).max(100).optional(),
  avatar: z.string().url().optional(),
});

// Middleware
export const validate = (schema: z.ZodSchema) => {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      schema.parse(req.body);
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        return ApiResponse.badRequest(res, 'Validation failed', error.errors);
      }
      next(error);
    }
  };
};
Outputs

1. Project Structure - Organized, scalable folder layout
2. API Layer - Controllers, routes, middleware
3. Service Layer - Business logic encapsulation
4. Repository Layer - Data access patterns
5. Database Schema - Prisma models with relations
6. Authentication - JWT auth with middleware
7. Error Handling - Centralized error management
8. Background Jobs - Queue processing setup
9. Input Validation - Zod schemas and middleware

Quality Gates
GateCriteriaStatusSecurityOWASP Top 10 mitigatedPerformancep95 response < 200msReliabilityError rate < 0.1%Test Coverage> 80% for servicesDocumentationOpenAPI spec complete
References & Best Practices
From The Pragmatic Engineer

* "The best backends are boring. Use proven patterns over novel solutions."
* Separate concerns: controllers don't have business logic.

From Martin Fowler

* "Repository pattern decouples business logic from data access."
* Service layer should be where business rules live.


Next Recommended Skill: /fullstack-integration - Connect frontend and backend.

---

```markdown
# SKILL: fullstack-integration

## Purpose

Integrate frontend and backend systems with secure authentication, end-to-end type safety, proper error handling, and seamless data flow. This skill ensures the entire stack works together cohesively.

## When to Use

- After `/frontend-engineering` and `/backend-engineering` are complete
- When implementing authentication flows
- When setting up API integration
- When establishing end-to-end type safety
- When implementing real-time features

## Role Activated

**Staff Fullstack Engineer + Integration Architect**

You think like engineers at Vercel or Supabase—creating seamless experiences where frontend and backend feel like one unified system.

## Inputs (Variables)

```yaml
{frontend_stack}: Next.js, React Query, etc.
{backend_stack}: Node.js, Express, Prisma
{auth_provider}: Custom JWT, Auth0, Clerk, NextAuth
{api_style}: REST, GraphQL, tRPC
{realtime_needs}: WebSockets, SSE, polling

Step-by-Step Process
Step 1: End-to-End Type Safety
typescriptDownloadCopy code// shared/types/api.ts - Shared between frontend and backend
export interface User {
  id: string;
  email: string;
  name: string | null;
  avatar: string | null;
  role: 'ADMIN' | 'MEMBER';
  createdAt: string;
}

export interface Project {
  id: string;
  name: string;
  slug: string;
  description: string | null;
  visibility: 'PUBLIC' | 'PRIVATE';
  createdAt: string;
}

// API Response Types
export interface ApiResponse<T> {
  success: true;
  data: T;
  meta: { timestamp: string };
}

export interface ApiError {
  success: false;
  error: {
    message: string;
    code: string;
    details?: unknown;
  };
}

export interface PaginatedResponse<T> extends ApiResponse<T[]> {
  meta: {
    timestamp: string;
    pagination: {
      total: number;
      page: number;
      limit: number;
      totalPages: number;
      hasMore: boolean;
    };
  };
}

// Request Types
export interface CreateProjectRequest {
  name: string;
  description?: string;
  visibility?: 'PUBLIC' | 'PRIVATE';
}

export interface UpdateProjectRequest {
  name?: string;
  description?: string;
  visibility?: 'PUBLIC' | 'PRIVATE';
}
Step 2: API Client with Type Safety
typescriptDownloadCopy code// frontend/lib/api-client.ts
import { ApiResponse, ApiError, User, Project } from '@shared/types/api';

class ApiClient {
  private baseUrl: string;
  private token: string | null = null;

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
  }

  setToken(token: string | null) {
    this.token = token;
  }

  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const url = `${this.baseUrl}${endpoint}`;

    const response = await fetch(url, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...(this.token && { Authorization: `Bearer ${this.token}` }),
        ...options.headers,
      },
    });

    const data = await response.json();

    if (!response.ok) {
      const error = data as ApiError;
      throw new ApiClientError(
        error.error.message,
        response.status,
        error.error.code
      );
    }

    return (data as ApiResponse<T>).data;
  }

  // Auth
  async login(email: string, password: string) {
    return this.request<{ user: User; token: string }>('/auth/login', {
      method: 'POST',
      body: JSON.stringify({ email, password }),
    });
  }

  async register(data: { email: string; password: string; name: string }) {
    return this.request<{ user: User; token: string }>('/auth/register', {
      method: 'POST',
      body: JSON.stringify(data),
    });
  }

  async getMe() {
    return this.request<User>('/auth/me');
  }

  // Projects
  async getProjects(params?: { page?: number; limit?: number }) {
    const query = new URLSearchParams(params as Record<string, string>);
    return this.request<Project[]>(`/projects?${query}`);
  }

  async getProject(id: string) {
    return this.request<Project>(`/projects/${id}`);
  }

  async createProject(data: CreateProjectRequest) {
    return this.request<Project>('/projects', {
      method: 'POST',
      body: JSON.stringify(data),
    });
  }

  async updateProject(id: string, data: UpdateProjectRequest) {
    return this.request<Project>(`/projects/${id}`, {
      method: 'PATCH',
      body: JSON.stringify(data),
    });
  }

  async deleteProject(id: string) {
    return this.request<void>(`/projects/${id}`, { method: 'DELETE' });
  }
}

export const api = new ApiClient(process.env.NEXT_PUBLIC_API_URL!);
Step 3: Authentication Flow
typescriptDownloadCopy code// frontend/lib/auth-context.tsx
'use client';

import { createContext, useContext, useEffect, useState, ReactNode } from 'react';
import { useRouter } from 'next/navigation';
import { api } from './api-client';
import { User } from '@shared/types/api';

interface AuthContextType {
  user: User | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  login: (email: string, password: string) => Promise<void>;
  register: (data: { email: string; password: string; name: string }) => Promise<void>;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType | null>(null);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const router = useRouter();

  useEffect(() => {
    const token = localStorage.getItem('token');
    if (token) {
      api.setToken(token);
      api.getMe()
        .then(setUser)
        .catch(() => {
          localStorage.removeItem('token');
          api.setToken(null);
        })
        .finally(() => setIsLoading(false));
    } else {
      setIsLoading(false);
    }
  }, []);

  const login = async (email: string, password: string) => {
    const { user, token } = await api.login(email, password);
    localStorage.setItem('token', token);
    api.setToken(token);
    setUser(user);
    router.push('/dashboard');
  };

  const register = async (data: { email: string; password: string; name: string }) => {
    const { user, token } = await api.register(data);
    localStorage.setItem('token', token);
    api.setToken(token);
    setUser(user);
    router.push('/dashboard');
  };

  const logout = () => {
    localStorage.removeItem('token');
    api.setToken(null);
    setUser(null);
    router.push('/login');
  };

  return (
    <AuthContext.Provider
      value={{
        user,
        isLoading,
        isAuthenticated: !!user,
        login,
        register,
        logout,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) throw new Error('useAuth must be used within AuthProvider');
  return context;
};
Step 4: Protected Routes
typescriptDownloadCopy code// frontend/components/auth/protected-route.tsx
'use client';

import { useAuth } from '@/lib/auth-context';
import { useRouter } from 'next/navigation';
import { useEffect } from 'react';

export function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const { isAuthenticated, isLoading } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!isLoading && !isAuthenticated) {
      router.push('/login');
    }
  }, [isAuthenticated, isLoading, router]);

  if (isLoading) {
    return <LoadingScreen />;
  }

  if (!isAuthenticated) {
    return null;
  }

  return <>{children}</>;
}

// Next.js middleware for server-side protection
// frontend/middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

const protectedPaths = ['/dashboard', '/projects', '/settings'];
const authPaths = ['/login', '/register'];

export function middleware(request: NextRequest) {
  const token = request.cookies.get('token')?.value;
  const { pathname } = request.nextUrl;

  // Redirect authenticated users away from auth pages
  if (authPaths.some(path => pathname.startsWith(path)) && token) {
    return NextResponse.redirect(new URL('/dashboard', request.url));
  }

  // Redirect unauthenticated users to login
  if (protectedPaths.some(path => pathname.startsWith(path)) && !token) {
    const loginUrl = new URL('/login', request.url);
    loginUrl.searchParams.set('redirect', pathname);
    return NextResponse.redirect(loginUrl);
  }

  return NextResponse.next();
}
Step 5: React Query Integration
typescriptDownloadCopy code// frontend/hooks/use-projects.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { api } from '@/lib/api-client';
import { toast } from 'sonner';

export const projectKeys = {
  all: ['projects'] as const,
  lists: () => [...projectKeys.all, 'list'] as const,
  list: (filters: Record<string, unknown>) => [...projectKeys.lists(), filters] as const,
  details: () => [...projectKeys.all, 'detail'] as const,
  detail: (id: string) => [...projectKeys.details(), id] as const,
};

export function useProjects(params?: { page?: number; limit?: number }) {
  return useQuery({
    queryKey: projectKeys.list(params || {}),
    queryFn: () => api.getProjects(params),
  });
}

export function useProject(id: string) {
  return useQuery({
    queryKey: projectKeys.detail(id),
    queryFn: () => api.getProject(id),
    enabled: !!id,
  });
}

export function useCreateProject() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: api.createProject.bind(api),
    onSuccess: (newProject) => {
      queryClient.invalidateQueries({ queryKey: projectKeys.lists() });
      toast.success('Project created successfully');
    },
    onError: (error: Error) => {
      toast.error(error.message || 'Failed to create project');
    },
  });
}

export function useUpdateProject() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateProjectRequest }) =>
      api.updateProject(id, data),
    onSuccess: (updatedProject) => {
      queryClient.invalidateQueries({ queryKey: projectKeys.detail(updatedProject.id) });
      queryClient.invalidateQueries({ queryKey: projectKeys.lists() });
      toast.success('Project updated');
    },
    onError: (error: Error) => {
      toast.error(error.message || 'Failed to update project');
    },
  });
}

export function useDeleteProject() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: api.deleteProject.bind(api),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: projectKeys.lists() });
      toast.success('Project deleted');
    },
    onError: (error: Error) => {
      toast.error(error.message || 'Failed to delete project');
    },
  });
}
Step 6: Real-time Integration
typescriptDownloadCopy code// backend/lib/websocket.ts
import { Server } from 'socket.io';
import { auth } from './auth';

export function setupWebSocket(httpServer: any) {
  const io = new Server(httpServer, {
    cors: { origin: process.env.CORS_ORIGIN },
  });

  // Authentication middleware
  io.use((socket, next) => {
    const token = socket.handshake.auth.token;
    try {
      const payload = auth.verifyToken(token);
      socket.data.user = payload;
      next();
    } catch {
      next(new Error('Authentication failed'));
    }
  });

  io.on('connection', (socket) => {
    const userId = socket.data.user.userId;

    // Join user's room for personal notifications
    socket.join(`user:${userId}`);

    // Join project rooms
    socket.on('join:project', (projectId: string) => {
      socket.join(`project:${projectId}`);
    });

    socket.on('leave:project', (projectId: string) => {
      socket.leave(`project:${projectId}`);
    });

    socket.on('disconnect', () => {
      console.log('Client disconnected:', userId);
    });
  });

  return io;
}

// Emit events from services
export function emitProjectUpdate(io: Server, projectId: string, data: any) {
  io.to(`project:${projectId}`).emit('project:updated', data);
}

// frontend/hooks/use-realtime.ts
import { useEffect } from 'react';
import { io, Socket } from 'socket.io-client';
import { useQueryClient } from '@tanstack/react-query';
import { projectKeys } from './use-projects';

let socket: Socket | null = null;

export function useRealtime(projectId?: string) {
  const queryClient = useQueryClient();

  useEffect(() => {
    const token = localStorage.getItem('token');
    if (!token) return;

    socket = io(process.env.NEXT_PUBLIC_WS_URL!, {
      auth: { token },
    });

    socket.on('connect', () => {
      if (projectId) {
        socket?.emit('join:project', projectId);
      }
    });

    socket.on('project:updated', (data) => {
      queryClient.invalidateQueries({ queryKey: projectKeys.detail(data.id) });
    });

    return () => {
      if (projectId) {
        socket?.emit('leave:project', projectId);
      }
      socket?.disconnect();
    };
  }, [projectId, queryClient]);
}
Step 7: Error Handling Integration
typescriptDownloadCopy code// frontend/lib/error-handler.ts
import { toast } from 'sonner';

export class ApiClientError extends Error {
  constructor(
    message: string,
    public status: number,
    public code?: string
  ) {
    super(message);
    this.name = 'ApiClientError';
  }
}

export function handleApiError(error: unknown) {
  if (error instanceof ApiClientError) {
    switch (error.status) {
      case 401:
        // Handle unauthorized - redirect to login
        localStorage.removeItem('token');
        window.location.href = '/login';
        break;
      case 403:
        toast.error('You do not have permission to perform this action');
        break;
      case 404:
        toast.error('The requested resource was not found');
        break;
      case 422:
        toast.error(error.message || 'Validation failed');
        break;
      case 429:
        toast.error('Too many requests. Please try again later.');
        break;
      default:
        toast.error(error.message || 'An error occurred');
    }
  } else {
    toast.error('An unexpected error occurred');
    console.error(error);
  }
}

// React Query global error handler
// frontend/lib/query-client.ts
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: (failureCount, error) => {
        if (error instanceof ApiClientError && error.status === 401) {
          return false;
        }
        return failureCount < 2;
      },
    },
    mutations: {
      onError: handleApiError,
    },
  },
});
Outputs

1. Shared Types - End-to-end type safety
2. API Client - Type-safe frontend API client
3. Auth Flow - Complete authentication implementation
4. Protected Routes - Client and server-side protection
5. Data Fetching - React Query hooks
6. Real-time - WebSocket integration
7. Error Handling - Unified error management

Quality Gates
GateCriteriaStatusType SafetyNo any types in API layerAuth SecurityTokens properly handledError UXAll errors show user feedbackLoading StatesAll async ops have loading UIOffline SupportGraceful degradation
References & Best Practices
From The Pragmatic Engineer

* "The best integrations are invisible to the user."
* Type safety at API boundaries prevents entire classes of bugs.

From tRPC/Tanstack

* End-to-end type safety eliminates API documentation drift.
* React Query patterns for server state management.
````
