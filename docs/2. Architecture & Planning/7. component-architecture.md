# Component Architecture

## 1. Hierarchy & Structure

Gebeta follows a modular component architecture designed for scale, performance, and maintainability.

### 1.1 Directory Structure
- `src/components/ui/`: Atomic primitive components (Buttons, Inputs, Badges). Pure UI, no business logic.
- `src/components/features/`: Complex modules organized by domain (Menu, Checkout, Dashboard). Contains business logic and state.
- `src/components/layouts/`: Global page structures (Navigation, Footer, Sidebar).
- `src/components/shared/`: Cross-feature utility components.

## 2. Component Design Principles

### 2.1 Pure Primitives
UI components must be:
- **Stateless**: Logic handled by parents.
- **Accessible**: ARIA compliant by default.
- **Themed**: Use CSS variables and design tokens.

### 2.2 Feature-Based Modules
Feature components should:
- Own their state (using Hooks or Context).
- Fetch data when appropriate (Client-side) or receive it from Server Components.
- Be lazy-loaded if they are large or non-critical.

## 3. Data Flow Pattern

### 3.1 Server Components (Next.js 15)
- All pages are Server Components by default.
- Data fetching happens at the Page level.
- Static content is rendered on the server for SEO.

### 3.2 Client Bridges
- Interactive parts are wrapped in Client Components.
- Use the "Leaf" strategy: Keep Client Components as deep in the tree as possible.

## 4. State Management Strategy

- **Server State**: Managed by Next.js Cache and Server Actions.
- **UI State**: Local `useState` for simple toggles.
- **Shared UI State**: React Context for global elements like the Cart or User Theme.
- **Forms**: React Hook Form + Zod for validation.

## 5. Testing Strategy

- **Unit Tests**: Vitest for utility functions and pure UI components.
- **Component Tests**: React Testing Library for feature logic.
- **E2E Tests**: Playwright for critical user flows (Menu -> Add to Cart -> Checkout).
- **Visual Regression**: Storybook Test Runner for UI consistency.