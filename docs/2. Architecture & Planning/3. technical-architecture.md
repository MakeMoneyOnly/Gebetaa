# Technical Architecture Document

## Overview

This document outlines the technical architecture for the Gebeta Restaurant Infrastructure Platform, a multi-tenant SaaS platform designed for emerging markets. The architecture prioritizes:

1. **Offline-First:** Works reliably on unreliable internet connections
2. **Multi-Tenant:** Serves unlimited restaurants from single codebase
3. **Scalable:** Grows from 500 to 100,000+ restaurants
4. **Performant:** Fast on 3G connections with older devices
5. **Secure:** Enterprise-grade security for customer data

---

## Technical Requirements Analysis

### Functional Requirements Summary

| Requirement | Technical Implication |
|-------------|----------------------|
| **Digital Menu with QR Codes** | Static site generation for menus, client-side rendering for admin |
| **Real-time Price Updates** | WebSocket subscriptions, optimistic UI updates |
| **Multi-Tenant Architecture** | Row-level security in PostgreSQL, tenant isolation |
| **Smart Upselling Engine** | Recommendation algorithm, co-occurrence analysis |
| **Menu Intelligence Dashboard** | Aggregation queries, data visualization |
| **Offline Mode** | Service Workers, IndexedDB, background sync |
| **Multi-Location Management** | Hierarchical data model, location-level permissions |
| **Local Payment Integration** | REST API integrations with payment providers |
| **Multi-Language Support** | i18n framework, RTL support for Arabic |
| **Multi-Currency Support** | Currency conversion rates, localized formatting |

---

### Non-Functional Requirements (Quality Attributes)

#### Performance

| Metric | Requirement | Justification |
|--------|-------------|---------------|
| **Menu Load Time** | < 3 seconds on 3G | Target market uses unreliable, slow connections |
| **API Response Time (p50)** | < 200ms | Fast interactive experience |
| **API Response Time (p95)** | < 500ms | Acceptable for non-critical operations |
| **API Response Time (p99)** | < 1000ms | Handles edge cases gracefully |
| **Throughput** | 1000 requests/second initially | 500 restaurants × 2 concurrent users |

#### Scalability

| Dimension | Current (MVP) | Year 1 | Year 3 |
|-----------|---------------|--------|--------|
| **Restaurants** | 500 | 5,000 | 100,000 |
| **Monthly Active Users** | 5,000 | 50,000 | 1,000,000 |
| **Daily Menu Views** | 10,000 | 100,000 | 2,000,000 |
| **Data Volume** | 10 GB | 100 GB | 2 TB |
| **API Requests/Day** | 1M | 10M | 200M |

#### Availability

| Metric | Target | Justification |
|--------|--------|---------------|
| **Uptime** | 99.5% | SaaS standard for business tools |
| **Downtime/Year** | < 44 hours | Allows for maintenance windows |
| **RTO (Recovery Time Objective)** | 4 hours | Acceptable for restaurant operations |
| **RPO (Recovery Point Objective)** | 1 hour | Minimize data loss |

#### Security

| Dimension | Requirement | Implementation |
|-----------|-------------|----------------|
| **Authentication** | JWT tokens with refresh | Supabase Auth |
| **Authorization** | Role-based (Owner, Manager, Staff) | Row-level security policies |
| **Data Protection** | AES-256 at rest, TLS 1.3 in transit | Supabase + Vercel |
| **API Security** | Rate limiting, input validation | Edge middleware |
| **Compliance** | GDPR (for EU users) | Data residency options |

#### Maintainability

| Metric | Target | Justification |
|--------|--------|---------------|
| **Deployment Frequency** | 10+ per week | Fast iteration capability |
| **Lead Time for Changes** | < 4 hours | Code to production quickly |
| **Mean Time to Recovery** | < 1 hour | Quick rollback capability |
| **Code Coverage** | > 80% | Maintainable test suite |
| **Documentation** | > 90% public APIs documented | Knowledge sharing |

---

### Technical Constraints

| Constraint | Impact | Mitigation |
|------------|--------|------------|
| **Older Android devices (6.0+)** | Must support older browsers | Polyfills, progressive enhancement |
| **Unreliable internet** | Offline-first architecture required | Service Workers, local caching |
| **Limited data plans** | Lightweight pages essential | Code splitting, lazy loading, compression |
| **Budget limitations** | Use cost-effective services | Vercel free tier, Supabase free tier |
| **Limited DevOps resources** | Managed services preferred | Supabase, Vercel, GitHub Actions |

---

### Integration Requirements

| System | Protocol | Data Flow | Criticality |
|--------|----------|-----------|-------------|
| **Supabase** | REST/PostgreSQL | Bidirectional | Critical |
| **Vercel** | HTTPS | Outbound | Critical |
| **Telebirr** | REST API | Outbound | Critical (Phase 2) |
| **M-Pesa** | REST API | Outbound | Critical (Phase 2) |
| **Cloudflare** | DNS/CDN | Outbound | High |
| **Analytics** | Event tracking | Outbound | Medium |

---

## Architecture Decision Records (ADRs)

### ADR-001: Frontend Framework Selection

**Status:** Accepted

**Date:** 2025-02-04

**Decision Makers:** SDLC Orchestrator

#### Context

We need to select a frontend framework that supports:
- Static site generation for digital menus (SEO, performance)
- Client-side rendering for admin dashboard (interactivity)
- Offline-first capabilities (Service Workers)
- Multi-language support
- Works on older Android browsers (6.0+)

#### Decision Drivers

- **Performance:** Must load fast on 3G connections
- **Developer Experience:** Team familiarity, community support
- **Ecosystem:** Libraries, tooling, documentation
- **Long-term Viability:** Active maintenance, roadmaps
- **Cost:** Free and open source preferred

#### Considered Options

**Option 1: React + Next.js**
- ✅ Largest ecosystem, familiar to most developers
- ✅ SSG/SSR support via Next.js
- ✅ Excellent offline support via Service Workers
- ✅ Great i18n support
- ❌ Larger bundle size than alternatives
- ❌ Learning curve for Next.js specific features

**Option 2: Vue + Nuxt.js**
- ✅ Smaller bundle size than React
- ✅ Easier learning curve
- ✅ Good SSG/SSR support via Nuxt.js
- ❌ Smaller ecosystem than React
- ❌ Less common in enterprise

**Option 3: Svelte + SvelteKit**
- ✅ Smallest bundle size (great for performance)
- ✅ Excellent performance metrics
- ✅ Growing ecosystem
- ❌ Smaller community than React
- ❌ Less mature than React ecosystem
- ❌ Fewer libraries available

**Option 4: Vanilla JS + Vite**
- ✅ Maximum performance, minimal overhead
- ✅ Full control over architecture
- ❌ More boilerplate, less productive
- ❌ No built-in SSR/SSG
- ❌ Reinventing the wheel

#### Decision

**Accepted: React + Next.js**

**Rationale:**
1. **Team Familiarity:** Most developers know React
2. **Ecosystem:** Largest selection of libraries and tools
3. **Performance:** Next.js provides excellent SSG/SSR capabilities
4. **Offline Support:** Service Workers integrate well
5. **Multi-Language:** Next.js has built-in i18n routing
6. **Cost:** Free and open source

**Implementation Notes:**
- Use Next.js App Router for modern features
- Use React Server Components for optimal performance
- Implement Service Workers for offline functionality
- Use Code splitting and lazy loading for performance

---

### ADR-002: Backend Infrastructure Selection

**Status:** Accepted

**Date:** 2025-02-04

**Decision Makers:** SDLC Orchestrator

#### Context

We need backend infrastructure that provides:
- Database (PostgreSQL)
- Authentication
- Realtime subscriptions
- File storage (images)
- API layer
- Serverless functions

#### Decision Drivers

- **Multi-Tenancy:** Row-level security is critical
- **Realtime:** Smart upselling requires realtime updates
- **Scalability:** Must handle 100,000+ restaurants
- **Cost:** Budget-friendly for startup phase
- **Developer Experience:** Fast development velocity
- **Offline Support:** Backend sync capabilities

#### Considered Options

**Option 1: Supabase**
- ✅ PostgreSQL database with Row-Level Security
- ✅ Built-in Authentication (JWT)
- ✅ Realtime subscriptions out of the box
- ✅ File storage for images
- ✅ Serverless functions (Edge Functions)
- ✅ Excellent free tier (500MB DB, 1GB file storage)
- ✅ TypeScript support
- ✅ Growing ecosystem
- ❌ Less mature than Firebase
- ❌ Some features still in beta

**Option 2: Firebase**
- ✅ Mature, battle-tested platform
- ✅ Excellent realtime capabilities
- ✅ Large ecosystem
- ❌ No SQL (Firestore limitations)
- ❌ Vendor lock-in concerns
- ❌ Cost can escalate quickly
- ❌ No PostgreSQL (NoSQL)

**Option 3: AWS Amplify**
- ✅ Full AWS ecosystem
- ✅ Good authentication
- ✅ Scalable infrastructure
- ❌ More complex setup
- ❌ Cost can escalate quickly
- ❌ Less developer-friendly than Supabase

**Option 4: Custom Backend (Node.js + PostgreSQL)**
- ✅ Full control over architecture
- ✅ No vendor lock-in
- ❌ More development time
- ❌ Need to implement auth, realtime, storage
- ❌ Higher operational overhead

#### Decision

**Accepted: Supabase**

**Rationale:**
1. **PostgreSQL:** Full SQL capabilities for complex queries
2. **Row-Level Security:** Best-in-class multi-tenant isolation
3. **Realtime:** Built-in subscriptions for live updates
4. **Authentication:** Ready-to-use JWT auth
5. **Cost:** Generous free tier for MVP
6. **TypeScript:** Strong TypeScript support
7. **Offline Support:** Works well with Service Workers
8. **Developer Experience:** Fast development velocity

**Implementation Notes:**
- Use Row-Level Security for multi-tenant isolation
- Use Supabase Auth for authentication
- Use Supabase Realtime for live updates
- Use Supabase Storage for image uploads
- Use Supabase Edge Functions for serverless logic

---

### ADR-003: Multi-Tenancy Strategy

**Status:** Accepted

**Date:** 2025-02-04

**Decision Makers:** SDLC Orchestrator

#### Context

We need a multi-tenant architecture that:
- Isolates data between restaurants
- Allows multi-location management
- Supports custom branding per tenant
- Scales to 100,000+ tenants
- Maintains performance across all tenants

#### Decision Drivers

- **Data Isolation:** Each restaurant must not see other restaurants' data
- **Cost Efficiency:** Share infrastructure across tenants
- **Performance:** No cross-tenant interference
- **Scalability:** Must handle 100,000+ tenants
- **Flexibility:** Support per-tenant customization

#### Considered Options

**Option 1: Database-Per-Tenant**
- ✅ Complete data isolation
- ✅ Easy backup/restore per tenant
- ❌ Cost prohibitive (100,000 databases)
- ❌ Complex migrations
- ❌ Connection pooling challenges

**Option 2: Schema-Per-Tenant**
- ✅ Good isolation at schema level
- ✅ Easier backups than database-per-tenant
- ❌ Migration complexity
- ❌ PostgreSQL has limitations with many schemas
- ❌ Connection pooling challenges

**Option 3: Row-Level Security (RLS)**
- ✅ Single database, single schema
- ✅ Strong isolation at row level
- ✅ Easy migrations
- ✅ Cost efficient
- ✅ Built into PostgreSQL
- ❌ Requires careful policy design
- ❌ Performance with many policies

**Option 4: Separate Columns with Tenant ID**
- ✅ Simple implementation
- ✅ Easy to query
- ❌ Risk of accidental data leakage
- ❌ Requires discipline in every query
- ❌ Complex authorization logic

#### Decision

**Accepted: Row-Level Security (RLS)**

**Rationale:**
1. **Built-in:** Native PostgreSQL feature
2. **Secure:** Enforces isolation at database level
3. **Cost-Effective:** Single database, single schema
4. **Scalable:** Handles 100,000+ tenants
5. **Maintainable:** Easy migrations
6. **Testable:** Policies can be unit tested

**Implementation Notes:**
- Every table includes `tenant_id` column
- RLS policies filter by `auth.uid()` or `organization_id`
- Application uses service role for migrations only
- Regular audits of RLS policies
- Performance testing with 10,000+ tenants

**Schema Pattern:**
```sql
CREATE TABLE restaurants (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL,
  name TEXT NOT NULL,
  owner_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT fk_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id)
);

CREATE POLICY "Owners can view own restaurants"
  ON restaurants FOR ALL
  USING (tenant_id = auth.uid());
```

---

### ADR-004: Offline-First Architecture

**Status:** Accepted

**Date:** 2025-02-04

**Decision Makers:** SDLC Orchestrator

#### Context

The target market has unreliable internet connectivity. We need an offline-first architecture that:
- Loads menus quickly even without internet
- Syncs data when connection is restored
- Provides graceful degradation
- Works on older Android devices (6.0+)

#### Decision Drivers

- **User Experience:** Must work despite connectivity issues
- **Performance:** Fast load times on slow connections
- **Reliability:** No data loss during offline periods
- **Compatibility:** Works on older browsers

#### Considered Options

**Option 1: Full Offline with Sync**
- ✅ Best user experience
- ✅ Works completely offline
- ❌ Complex synchronization logic
- ❌ Risk of conflicts
- ❌ Larger client-side footprint

**Option 2: Cached Content Only**
- ✅ Simpler implementation
- ✅ Good for static content
- ❌ Limited functionality offline
- ❌ Not suitable for admin dashboard

**Option 3: Graceful Degradation**
- ✅ Simpler than full offline
- ✅ Clear offline experience
- ❌ Limited offline functionality
- ❌ User disappointment when offline

**Option 4: Hybrid Approach**
- ✅ Best of both worlds
- ✅ Static content cached fully
- ✅ Dynamic content with sync
- ❌ More complex implementation
- ❌ Requires careful architecture

#### Decision

**Accepted: Hybrid Approach**

**Rationale:**
1. **Digital Menu (Public):** Fully cached, works offline
2. **Admin Dashboard:** Graceful degradation, basic read-only offline
3. **Data Sync:** Background sync when connection restored
4. **Compatibility:** Works on older browsers with progressive enhancement

**Implementation Notes:**
- Service Worker for caching strategies
- IndexedDB for client-side storage
- Background Sync API for deferred writes
- Optimistic UI updates
- Clear offline indicators
- Manual refresh option

**Caching Strategy:**
```
Menus: Cache-First (stale-while-revalidate)
API Data: Network-First (fallback to cache)
Images: Cache-First (with cache expiration)
Static Assets: Stale-While-Revalidate
```

---

### ADR-005: Recommendation Engine Architecture

**Status:** Proposed

**Date:** 2025-02-04

**Decision Makers:** SDLC Orchestrator

#### Context

We need a smart upselling engine that:
- Analyzes order history for co-occurrence patterns
- Provides real-time recommendations
- Supports category-based rules
- Tracks conversion rates
- Improves over time with more data

#### Decision Drivers

- **Real-Time:** Must respond quickly (< 100ms)
- **Scalable:** Must handle millions of orders
- **Accuracy:** Recommendations must be relevant
- **Cost:** Must be cost-effective for startup
- **Simplicity:** MVP should not over-engineer

#### Considered Options

**Option 1: Real-Time ML Pipeline**
- ✅ Most accurate recommendations
- ✅ Learns from user behavior
- ❌ Complex infrastructure
- ❌ Expensive to operate
- ❌ Over-engineered for MVP

**Option 2: Pre-Computed Recommendations**
- ✅ Fast response times
- ✅ Simple infrastructure
- ✅ Cost-effective
- ❌ Less personalized
- ❌ Updates require reprocessing

**Option 3: Hybrid Rules + Co-Occurrence**
- ✅ Simple to implement
- ✅ Fast response times
- ✅ Good accuracy for MVP
- ✅ Easy to explain recommendations
- ❌ Less sophisticated than ML

#### Decision

**Accepted: Hybrid Rules + Co-Occurrence**

**Rationale:**
1. **Simplicity:** Easy to implement and maintain
2. **Performance:** Fast response times
3. **Accuracy:** Good enough for MVP (19-30% AOV increase target)
4. **Cost-Effective:** No expensive ML infrastructure
5. **Explainable:** Easy to understand why items are recommended

**Implementation Approach:**

**Phase 1 (MVP):**
- Co-occurrence analysis from order history
- "Often ordered together" suggestions
- Category-based rules (drinks with meals)
- Margin optimization (slight bias toward high-margin items)

**Phase 2:**
- Collaborative filtering
- Personalized recommendations based on user history
- A/B testing framework

**Phase 3:**
- Machine learning pipeline
- Real-time personalization
- Advanced pattern recognition

**Algorithm (MVP):**
```
1. Count co-occurrences: For each item pair (A, B), count how often ordered together
2. Normalize: Divide by total orders containing A
3. Threshold: Only suggest if co-occurrence > 5%
4. Rank: Sort by co-occurrence rate
5. Limit: Max 2 suggestions per item
```

---

### ADR-006: Payment Integration Strategy

**Status:** Proposed

**Date:** 2025-02-04

**Decision Makers:** SDLC Orchestrator

#### Context

We need to integrate with local payment providers in emerging markets:
- **Ethiopia:** Telebirr
- **Kenya:** M-Pesa
- **South Africa:** Standard Bank, FNB
- **Nigeria:** Flutterwave, Paystack

#### Decision Drivers

- **Local Market:** Must support preferred payment methods
- **Reliability:** Must have fallback options
- **Security:** PCI-DSS compliance where required
- **Cost:** Transaction fees must be reasonable
- **Integration:** Easy to integrate and maintain

#### Considered Options

**Option 1: Direct Integration**
- ✅ Full control over integration
- ✅ Lower fees possible
- ❌ Complex implementation
- ❌ Multiple integrations to maintain
- ❌ Regulatory compliance burden

**Option 2: Payment Aggregator**
- ✅ Single integration for multiple providers
- ✅ Handles compliance
- ✅ Easier maintenance
- ❌ Higher fees
- ❌ Less control

**Option 3: Hybrid**
- ✅ Best of both worlds
- ✅ Control for critical markets
- ✅ Aggregation for others
- ❌ More complex architecture

#### Decision

**Accepted: Hybrid Approach**

**Rationale:**
1. **Primary Markets:** Direct integration for Telebirr (Ethiopia) and M-Pesa (Kenya)
2. **Secondary Markets:** Use aggregators like Flutterwave
3. **Flexibility:** Easy to switch providers
4. **Reliability:** Fallback options available

**Implementation Plan:**

**Phase 1 (MVP):** No payments (future consideration)

**Phase 2:**
- Telebirr integration (Ethiopia)
- M-Pesa integration (Kenya)

**Phase 3:**
- Flutterwave integration (Nigeria, Ghana)
- Additional providers as needed

---

## System Architecture

### High-Level Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                        USER LAYER                                │
├─────────────────────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐   │
│  │ Mobile Menu  │  │ Admin Portal │  │ Public Website       │   │
│  │ (PWA)       │  │ (React)      │  │ (Next.js)           │   │
│  └──────┬───────┘  └──────┬───────┘  └──────────┬───────────┘   │
├─────────┼────────────────┼──────────────────────┼───────────────┤
│         │                │                      │               │
│         └────────────────┴──────────────────────┘               │
│                           │                                      │
│                           ▼                                      │
│              ┌─────────────────────────┐                          │
│              │    Vercel Edge Network  │                         │
│              │  (CDN + Edge Functions) │                         │
│              └───────────┬─────────────┘                          │
│                          │                                        │
│                          ▼                                        │
│    ┌─────────────────────────────────────────────────────────┐    │
│    │                  API GATEWAY                          │    │
│    │         (Rate Limiting + Authentication)               │    │
│    └───────────────────────┬───────────────────────────────┘    │
│                            │                                    │
│            ┌───────────────┼───────────────┐                    │
│            │               │               │                    │
│            ▼               ▼               ▼                    │
│    ┌─────────────┐ ┌─────────────┐ ┌─────────────┐            │
│    │ Supabase    │ │   Vercel    │ │  External   │            │
│    │ Backend     │ │ Edge Funcs  │ │   APIs     │            │
│    │ (Database)  │ │ (Serverless)│ │ (Payments) │            │
│    └─────────────┘ └─────────────┘ └─────────────┘            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Component Details

#### Digital Menu (PWA)

**Purpose:** Public-facing digital menu accessible via QR code

**Technology:**
- Next.js (Static Site Generation)
- React
- Service Worker (offline support)
- IndexedDB (local caching)

**Key Features:**
- Loads in < 3 seconds on 3G
- Works offline (cached menu)
- Multi-language support
- Multi-currency display
- Responsive design (mobile-first)

#### Admin Dashboard

**Purpose:** Restaurant management interface for owners/managers

**Technology:**
- Next.js (Client-Side Rendering)
- React
- Recharts (analytics visualization)
- React Query (data fetching)

**Key Features:**
- Menu management (CRUD operations)
- Analytics dashboard
- QR code generation
- Location management
- Upselling configuration

#### Backend Services

**Purpose:** API layer, database, authentication

**Technology:**
- Supabase (PostgreSQL)
- Supabase Auth (JWT)
- Supabase Realtime (live updates)
- Supabase Storage (images)
- Supabase Edge Functions (serverless)

**Key Features:**
- RESTful API
- WebSocket subscriptions
- Row-Level Security (multi-tenant)
- File storage
- Background functions

#### External Integrations

**Purpose:** Connect with third-party services

**Technology:**
- REST APIs
- Webhooks

**Integrations:**
- Telebirr (Phase 2)
- M-Pesa (Phase 2)
- Analytics services

---

### Data Model

#### Core Tables

```sql
-- Tenants (organizations/companies)
CREATE TABLE tenants (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  plan TEXT NOT NULL DEFAULT 'starter',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  settings JSONB DEFAULT '{}'
);

-- Restaurants (locations)
CREATE TABLE restaurants (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id),
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  address TEXT,
  phone TEXT,
  timezone TEXT DEFAULT 'Africa/Addis_Ababa',
  currency TEXT DEFAULT 'ETB',
  language TEXT DEFAULT 'en',
  branding JSONB DEFAULT '{}',
  settings JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Categories
CREATE TABLE categories (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  restaurant_id UUID NOT NULL REFERENCES restaurants(id),
  name TEXT NOT NULL,
  description TEXT,
  sort_order INT DEFAULT 0,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Menu Items
CREATE TABLE menu_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  restaurant_id UUID NOT NULL REFERENCES restaurants(id),
  category_id UUID REFERENCES categories(id),
  name TEXT NOT NULL,
  description TEXT,
  price DECIMAL(10, 2) NOT NULL,
  image_url TEXT,
  is_available BOOLEAN DEFAULT TRUE,
  is_featured BOOLEAN DEFAULT FALSE,
  sort_order INT DEFAULT 0,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Upselling Rules
CREATE TABLE upselling_rules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  restaurant_id UUID NOT NULL REFERENCES restaurants(id),
  name TEXT NOT NULL,
  type TEXT NOT NULL, -- 'co_occurrence', 'category', 'manual'
  source_item_id UUID REFERENCES menu_items(id),
  target_item_ids UUID[] NOT NULL,
  priority INT DEFAULT 0,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Orders (for upselling analysis)
CREATE TABLE orders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  restaurant_id UUID NOT NULL REFERENCES restaurants(id),
  table_number TEXT,
  items JSONB NOT NULL,
  subtotal DECIMAL(10, 2) NOT NULL,
  tax DECIMAL(10, 2) DEFAULT 0,
  total DECIMAL(10, 2) NOT NULL,
  status TEXT DEFAULT 'pending',
  source TEXT DEFAULT 'menu', -- 'menu', 'admin', 'aggregator'
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Order Items (for co-occurrence analysis)
CREATE TABLE order_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  order_id UUID NOT NULL REFERENCES orders(id),
  menu_item_id UUID NOT NULL REFERENCES menu_items(id),
  quantity INT NOT NULL DEFAULT 1,
  price DECIMAL(10, 2) NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Users
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID REFERENCES tenants(id),
  restaurant_id UUID REFERENCES restaurants(id),
  email TEXT UNIQUE NOT NULL,
  name TEXT,
  role TEXT NOT NULL DEFAULT 'staff', -- 'owner', 'manager', 'staff'
  avatar_url TEXT,
  settings JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Analytics Events
CREATE TABLE analytics_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  restaurant_id UUID NOT NULL REFERENCES restaurants(id),
  event_type TEXT NOT NULL,
  event_data JSONB DEFAULT '{}',
  user_id UUID REFERENCES users(id),
  session_id TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

---

### API Endpoints

#### Authentication

```
POST /auth/v1/signup
POST /auth/v1/token?grant_type=password
POST /auth/v1/token?grant_type=refresh_token
GET  /auth/v1/user
PUT  /auth/v1/user
DELETE /auth/v1/logout
```

#### Restaurants

```
GET    /restaurants
GET    /restaurants/:id
POST   /restaurants
PUT    /restaurants/:id
DELETE /restaurants/:id
GET    /restaurants/:id/stats
```

#### Menu

```
GET    /restaurants/:id/menu
GET    /restaurants/:id/menu/categories
GET    /restaurants/:id/menu/categories/:categoryId
POST   /restaurants/:id/menu/categories
PUT    /restaurants/:id/menu/categories/:categoryId
DELETE /restaurants/:id/menu/categories/:categoryId
GET    /restaurants/:id/menu/items
POST   /restaurants/:id/menu/items
GET    /restaurants/:id/menu/items/:itemId
PUT    /restaurants/:id/menu/items/:itemId
DELETE /restaurants/:id/menu/items/:itemId
```

#### QR Codes

```
GET    /restaurants/:id/qr-codes
POST   /restaurants/:id/qr-codes
GET    /restaurants/:id/qr-codes/:codeId/download
```

#### Analytics

```
GET  /restaurants/:id/analytics/views
GET  /restaurants/:id/analytics/popular-items
GET  /restaurants/:id/analytics/conversion
GET  /restaurants/:id/analytics/upselling
GET  /restaurants/:id/analytics/revenue
```

#### Upselling

```
GET  /restaurants/:id/upselling/rules
POST /restaurants/:id/upselling/rules
PUT  /restaurants/:id/upselling/rules/:ruleId
DELETE /restaurants/:id/upselling/rules/:ruleId
GET  /restaurants/:id/upselling/analytics
```

---

### Performance Optimization Strategy

#### Frontend Optimizations

1. **Code Splitting:** Lazy load routes and components
2. **Image Optimization:** WebP format, lazy loading
3. **Caching:** Service Worker for offline support
4. **Compression:** Gzip/Brotli compression
5. **CDN:** Vercel Edge Network
6. **Bundle Size:** Tree shaking, remove unused code
7. **Preloading:** Prefetch critical resources
8. **Lazy Loading:** Defer non-critical resources

#### Backend Optimizations

1. **Database Indexing:** Index frequently queried columns
2. **Query Optimization:** Avoid N+1 queries
3. **Connection Pooling:** Supabase handles this
4. **Caching:** Redis cache for frequently accessed data
5. **Pagination:** Cursor-based pagination for large datasets
6. **Rate Limiting:** Prevent abuse
7. **Async Processing:** Background jobs for heavy operations

#### Network Optimizations

1. **HTTP/2:** Multiplexed requests
2. **Connection Keep-Alive:** Reduce connection overhead
3. **DNS Prefetch:** Pre-resolve external domains
4. **Preconnect:** Early connection to critical domains

---

### Security Architecture

#### Authentication Flow

```
1. User submits email/password
2. Supabase Auth validates credentials
3. Returns JWT access token + refresh token
4. Client stores tokens securely
5. Client includes token in API requests
6. Backend validates token on each request
7. Token expires after 1 hour
8. Client uses refresh token to get new access token
```

#### Row-Level Security

```sql
-- Enable RLS on all tables
ALTER TABLE restaurants ENABLE ROW LEVEL SECURITY;

-- Policy: Users can only access their own restaurant
CREATE POLICY "Owners can access own restaurant"
  ON restaurants FOR ALL
  USING (tenant_id IN (
    SELECT tenant_id FROM users WHERE id = auth.uid()
  ));
```

#### API Security

1. **Rate Limiting:** 100 requests/minute per user
2. **Input Validation:** Zod schemas for all inputs
3. **Output Encoding:** Prevent XSS attacks
4. **CORS:** Restrict to approved origins
5. **Helmet:** Security headers
6. **HTTPS:** Enforce TLS 1.3
7. **Audit Logging:** Log all security-relevant events

---

### Deployment Architecture

#### Environment Strategy

| Environment | Purpose | Data |
|-------------|---------|------|
| **Development** | Local development | Mock data |
| **Staging** | QA and testing | Sanitized production data |
| **Production** | Live users | Real customer data |

#### CI/CD Pipeline

```
GitHub Actions Workflow:
1. Code push to main branch
2. Run tests (unit, integration)
3. Build Docker image
4. Deploy to staging
5. Run E2E tests
6. Deploy to production (automatic)
7. Monitor metrics
```

#### Infrastructure

| Service | Development | Production |
|---------|--------------|-------------|
| **Frontend** | Vercel (free) | Vercel (Pro) |
| **Backend** | Supabase (free) | Supabase (Pro) |
| **CDN** | Vercel Edge | Vercel Edge |
| **Monitoring** | Console logs | Datadog |
| **Error Tracking** | Console errors | Sentry |

---

## Document Metadata

- **Created:** 2025-02-04
- **Author:** SDLC Orchestrator
- **Phase:** Phase 2 - Architecture & Planning
- **Skill:** Technical Architecture (skill 3)
- **Status:** ✅ Complete
- **Next Skill:** Brand Identity (skill 4)